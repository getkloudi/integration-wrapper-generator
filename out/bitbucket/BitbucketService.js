const Axios = require("axios");
const ErrorHelper = require("../../../helpers/ErrorHelper");
const nconf = require("nconf");
const qs = require("querystring");

/* document_link : "https://developer.atlassian.com/cloud/bitbucket/oauth-2/",
 * rfc_link: "https://tools.ietf.org/html/draft-ietf-oauth-v2-31#section-1.3.1"
 * clone through OAUTH2 link : https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html#OAuthonBitbucketCloud-Cloningarepositorywithanaccesstoken
 */

const SCOPES = [
  "issue:write",
  "repository",
  "pullrequest",
  "team",
  "webhook",
  "project",
  "account",
  "email"
];

class BitbucketService {
  get name() {
    return "BITBUCKET";
  }

  get description() {
    return `One place to plan projects, collaborate on code, test and deploy, all with free private repositories`;
  }

  get icon() {
    return "bitbucket.svg";
  }

  get category() {
    return;
  }

  get apiEndpoint() {
    return "https://api.bitbucket.org/2.0";
  }

  get authMethod() {
    return "OAUTH2";
  }

  get authEndpoint() {
    return (
      `https://bitbucket.org/site/oauth2/authorize?` +
      `client_id=${nconf.get("BITBUCKET_CLIENT_ID")}&` +
      `scope=${qs.escape(this.scopes.join(" "))}&` +
      `response_type=code`
    );
  }

  get apiTokenURL() {
    return;
  }

  get scopes() {
    return [...SCOPES];
  }

  get requiredAuthParams() {
    return ["code"];
  }

  get primaryAction() {
    return {
      type: "HREF",
      url: this.authEndpoint,
      requiredAuthParams: this.requiredAuthParams
    };
  }

  get webhooks() {
    return [
      // "project:updated",
      "pullrequest:created",
      "pullrequest:updated",
      "pullrequest:approved",
      "pullrequest:unapproved",
      "pullrequest:fulfilled",
      "pullrequest:rejected",
      "pullrequest:comment_created",
      "pullrequest:comment_updated",
      // "repo:updated"
      "issue:comment_created",
      "issue:created",
      "issue:updated",
      "repo:push"
    ];
  }

  get webhookToTasksMap() {
    return [
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:created"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:updated"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:approved"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:unapproved"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:fulfilled"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:rejected"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:comment_created"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_PR",
        webhook: "pullrequest:comment_updated"
      },
      { name: "task.pepper.SYNC_BITBUCKET_COMMITS", webhook: "repo:push" },
      {
        name: "task.pepper.SYNC_BITBUCKET_TEAM_MEMBERS",
        webhook: "repo:push"
      },
      // { name: "", webhook: "repo:updated" },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_ISSUE",
        webhook: "issue:created"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_ISSUE",
        webhook: "issue:updated"
      },
      {
        name: "task.thirdParty.UPDATE_BITBUCKET_ISSUE",
        webhook: "issue:comment_created"
      }
    ];
  }

  get entities() {
    return [
      "PROJECTS",
      "REPOS",
      "MEMBERS",
      "TEAMS",
      // PRs- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/pullrequests
      // PR from ID- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/pullrequests/%7Bpull_request_id%7D
      "PULL_REQUESTS",
      // Comments for an PR- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/pullrequests/%7Bpull_request_id%7D/comments
      "PULL_REQUEST_COMMENTS",
      // Commit for an PR- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/pullrequests/%7Bpull_request_id%7D/commits
      "PULL_REQUEST_COMMITS",
      // Issues- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues
      // Issue from ID- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D
      "ISSUES",
      // Comments for an issue- https://developer.atlassian.com/bitbucket/api/2/reference/resource/repositories/%7Busername%7D/%7Brepo_slug%7D/issues/%7Bissue_id%7D/comments
      "ISSUE_COMMENTS"
    ];
  }

  async getAccessToken(integration) {
    /*
     * https://developer.atlassian.com/bitbucket/api/2/reference/meta/authentication
     */
    const res = await Axios.default.post(
      "https://bitbucket.org/site/oauth2/access_token",
      qs.stringify({
        grant_type: "refresh_token",
        refresh_token: integration.authRefreshToken
      }),
      {
        auth: {
          username: nconf.get("BITBUCKET_CLIENT_ID"),
          password: nconf.get("BITBUCKET_CLIENT_SECRET")
        }
      }
    );
    return res.data.access_token;
  }

  getNextPaginationURIFromResponse(response) {
    if (!response.body.next) return;
    else
      return Object.fromEntries(
        new URLSearchParams(require("url").parse(response.body.next).query)
      );
  }

  async connect(authParams) {
    /*
     * https://developer.atlassian.com/bitbucket/api/2/reference/meta/authentication
     */
    const authRes = await Axios.default.post(
      "https://bitbucket.org/site/oauth2/access_token",
      qs.stringify({
        grant_type: "authorization_code",
        code: authParams.code
      }),
      {
        auth: {
          username: nconf.get("BITBUCKET_CLIENT_ID"),
          password: nconf.get("BITBUCKET_CLIENT_SECRET")
        }
      }
    );
    const user = await this.get("USER", {
      accessToken: authRes.data.access_token
    });

    let teamUsernames = [],
      incomingOptions = { opts: {} };
    while (true) {
      const teams = await this.get("TEAMS", {
        accessToken: authRes.data.access_token,
        opts: { role: "contributor" }
      });
      incomingOptions.opts = this.getNextPaginationURIFromResponse(
        teams.response
      );
      teamUsernames = teamUsernames.concat(
        teams.data.values.map(item => item.username)
      );
      if (!incomingOptions.opts || !incomingOptions.opts.page) break;
    }

    return {
      accessToken: authRes.data.access_token,
      refreshToken: authRes.data.refresh_token,
      integrationSpecificParams: {
        username: user.data.username,
        uuid: user.data.uuid,
        team: { usernames: teamUsernames },
        authAccessTokenExpiresAt: Date.now() + authRes.data.expires_in * 1000
      }
    };
  }

  async getThirdPartyProjects(incomingOptions) {
    let res,
      options = incomingOptions.opts,
      repos = [];

    while (true) {
      res = await this.get("REPOSITORIES_WORKSPACE", {
        ...incomingOptions,
        workspace: incomingOptions.username
      });
      incomingOptions.opts = this.getNextPaginationURIFromResponse(
        res.response
      );
      repos = repos.concat(res.data.values);
      if (!incomingOptions.opts || !incomingOptions.opts.page) break;
    }

    for (const username of incomingOptions.team.usernames) {
      incomingOptions.opts = options;
      while (true) {
        res = await this.get("REPOSITORIES_WORKSPACE", {
          ...incomingOptions,
          workspace: username
        });
        incomingOptions.opts = this.getNextPaginationURIFromResponse(
          res.response
        );
        repos = repos.concat(res.data.values);
        if (!incomingOptions.opts || !incomingOptions.opts.page) break;
      }
    }
    repos.sort(function(a, b) {
      if (a.updated_on > b.updated_on) return -1;
      else if (a.updated_on < b.updated_on) return 1;
      else return 0;
    });
    return { data: repos };
  }

  async registerWebhooks(incomingOptions) {
    let data, res;

    res = await this.get(
      "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS",
      incomingOptions
    );
    data = res.data.values;
    const webhooks = data.filter(
      item =>
        item.url === incomingOptions.body.webhookURL &&
        item.events.sort().toString() ===
          incomingOptions.body.webhookEvents.sort().toString()
    );
    if (webhooks && webhooks.length > 0) return "Ok";

    const body = {
      description: "Webhook for Kloudi",
      active: true,
      events: incomingOptions.body.webhookEvents,
      url: incomingOptions.body.webhookURL
    };
    delete incomingOptions.body;
    try {
      res = await this.post("REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS", {
        body: body,
        ...incomingOptions
      });
    } catch (err) {
    } finally {
      if (res.response.status == 201) return "Ok";
      else return "ERROR";
    }
  }

  async syncIntegrationEntities(integration, incomingOptions) {
    const taskUri = nconf.get("TASK_API_URI");
    const authToken = nconf.get("PEPPER_TASK_API_ACCESS_TOKEN");

    try {
      //TODO: Add custom syncIntegrationEntities functionality here
      const res = await Axios.default.post(
        taskUri,
        {
          pepper_task: [
            "task.pepper.SYNC_BITBUCKET_TEAM_MEMBERS",
            "task.pepper.SYNC_BITBUCKET_PRS",
            "task.pepper.SYNC_BITBUCKET_COMMITS"
          ],
          project_id: incomingOptions.projectId,
          user_id: incomingOptions.userId,
          third_party_project_id: incomingOptions.repoSlug,
          third_party_organization_id: incomingOptions.workspace,
          bitbucket_username: incomingOptions.username,
          repo_endpoint: `${incomingOptions.workspace}/${incomingOptions.repoSlug}`
        },
        {
          headers: {
            Authorization: authToken
          }
        }
      );
      return "Ok";
    } catch (error) {
      console.error(error.response || error);
      return "ERROR";
    }
  }

  async get(entity, options) {
    switch (entity) {
      case "REPOSITORIES_WORKSPACE_REPO_SLUG_FILEHISTORY_NODE_PATH":
        /*



Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;      $ hg log --follow &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](../../../../../../meta/filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.


      Function parameters for this API node,path,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugFilehistoryNodePathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_SRC":
        /*



This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{node}/{path}](src/%7Bnode%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugSrcGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_SRC_NODE_PATH":
        /*



This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  ## Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  ## File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   ## Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  ## Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](../../../../../../meta/filtering) for more details.


      Function parameters for this API node,path,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugSrcNodePathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCHING_MODEL":
        /*



Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](branching-model/settings#get) API.  The returned object:  1. Always has a &#x60;development&#x60; property. &#x60;development.branch&#x60; contains    the actual repository branch object that is considered to be the    &#x60;development&#x60; branch. &#x60;development.branch&#x60; will not be present    if it does not exist. 2. Might have a &#x60;production&#x60; property. &#x60;production&#x60; will not    be present when &#x60;production&#x60; is disabled.    &#x60;production.branch&#x60; contains the actual branch object that is    considered to be the &#x60;production&#x60; branch. &#x60;production.branch&#x60; will    not be present if it does not exist. 3. Always has a &#x60;branch_types&#x60; array which contains all enabled branch    types.  Example body:  &#x60;&#x60;&#x60; {   \&quot;development\&quot;: {     \&quot;name\&quot;: \&quot;master\&quot;,     \&quot;branch\&quot;: {       \&quot;type\&quot;: \&quot;branch\&quot;,       \&quot;name\&quot;: \&quot;master\&quot;,       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;16dffcb0de1b22e249db6799532074cf32efe80f\&quot;       }     },     \&quot;use_mainbranch\&quot;: true   },   \&quot;production\&quot;: {     \&quot;name\&quot;: \&quot;production\&quot;,     \&quot;branch\&quot;: {       \&quot;type\&quot;: \&quot;branch\&quot;,       \&quot;name\&quot;: \&quot;production\&quot;,       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;16dffcb0de1b22e249db6799532074cf32efe80f\&quot;       }     },     \&quot;use_mainbranch\&quot;: false   },   \&quot;branch_types\&quot;: [     {       \&quot;kind\&quot;: \&quot;release\&quot;,       \&quot;prefix\&quot;: \&quot;release/\&quot;     },     {       \&quot;kind\&quot;: \&quot;hotfix\&quot;,       \&quot;prefix\&quot;: \&quot;hotfix/\&quot;     },     {       \&quot;kind\&quot;: \&quot;feature\&quot;,       \&quot;prefix\&quot;: \&quot;feature/\&quot;     },     {       \&quot;kind\&quot;: \&quot;bugfix\&quot;,       \&quot;prefix\&quot;: \&quot;bugfix/\&quot;     }   ],   \&quot;type\&quot;: \&quot;branching_model\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/.../branching-model\&quot;     }   } } &#x60;&#x60;&#x60;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchingModelGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCHING_MODEL_SETTINGS":
        /*



Return the branching model configuration for a repository. The returned object:  1. Always has a &#x60;development&#x60; property for the development branch. 2. Always a &#x60;production&#x60; property for the production branch. The    production branch can be disabled. 3. The &#x60;branch_types&#x60; contains all the branch types.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](../branching-model#get) more useful.  Example body:  &#x60;&#x60;&#x60; {   \&quot;development\&quot;: {     \&quot;is_valid\&quot;: true,     \&quot;name\&quot;: null,     \&quot;use_mainbranch\&quot;: true   },   \&quot;production\&quot;: {     \&quot;is_valid\&quot;: true,     \&quot;name\&quot;: \&quot;production\&quot;,     \&quot;use_mainbranch\&quot;: false,     \&quot;enabled\&quot;: false   },   \&quot;branch_types\&quot;: [     {       \&quot;kind\&quot;: \&quot;release\&quot;,       \&quot;enabled\&quot;: true,       \&quot;prefix\&quot;: \&quot;release/\&quot;     },     {       \&quot;kind\&quot;: \&quot;hotfix\&quot;,       \&quot;enabled\&quot;: true,       \&quot;prefix\&quot;: \&quot;hotfix/\&quot;     },     {       \&quot;kind\&quot;: \&quot;feature\&quot;,       \&quot;enabled\&quot;: true,       \&quot;prefix\&quot;: \&quot;feature/\&quot;     },     {       \&quot;kind\&quot;: \&quot;bugfix\&quot;,       \&quot;enabled\&quot;: false,       \&quot;prefix\&quot;: \&quot;bugfix/\&quot;     }   ],   \&quot;type\&quot;: \&quot;branching_model_settings\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/.../branching-model/settings\&quot;     }   } } &#x60;&#x60;&#x60;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_REPOSITORIES":
        /*



All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameRepositoriesGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USER_EMAILS_EMAIL":
        /*



Returns details about a specific one of the authenticated user&#39;s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user&#39;s primary address or not.


      Function parameters for this API email
        */
        return new Promise((resolve, reject) => {
          this.userEmailsEmailGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USER_EMAILS":
        /*



Returns all the authenticated user&#39;s email addresses. Both confirmed and unconfirmed.


      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.userEmailsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USER":
        /*



Returns the currently logged in user.


      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.userGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_FOLLOWERS":
        /*



Returns the list of accounts that are following this user.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameFollowersGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_FOLLOWING":
        /*



Returns the list of accounts this user is following.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameFollowingGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME":
        /*



Gets the public information associated with a user account.  If the user&#39;s profile is private, &#x60;location&#x60;, &#x60;website&#x60; and &#x60;created_on&#x60; elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS":
        /*



Returns a paginated list of webhooks installed on this user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS_UID":
        /*



Returns the webhook with the specified id installed on the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksUidGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_REPOSITORIES":
        /*



All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameRepositoriesGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_COMMIT_HOSTED_PROPERTY_VA":
        /*



Retrieve an application property value stored against a commit.


      Function parameters for this API username,repoSlug,commit,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.getCommitHostedPropertyValue(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PULL_REQUEST_HOSTED_PROPERTY_VA":
        /*



Retrieve an application property value stored against a pull request.


      Function parameters for this API username,repoSlug,pullrequestId,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.getPullRequestHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_REPOSITORY_HOSTED_PROPERTY_VA":
        /*



Retrieve an application property value stored against a repository.


      Function parameters for this API username,repoSlug,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "RETRIEVE_USER_HOSTED_PROPERTY_VA":
        /*



Retrieve an application property value stored against a user.


      Function parameters for this API username,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.retrieveUserHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES_BUILD_KEY":
        /*



Returns the specified build status for a commit.


      Function parameters for this API node,key,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES":
        /*



Returns all statuses (e.g. build results) for a specific commit.


      Function parameters for this API node,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_STATUSES":
        /*



Returns all statuses (e.g. build results) for the given pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEPLOY_KEYS":
        /*



Returns all deploy-keys belonging to a repository.  Example: &#x60;&#x60;&#x60; $ curl -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys  Output: {     \&quot;pagelen\&quot;: 10,     \&quot;values\&quot;: [         {             \&quot;id\&quot;: 123,             \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,             \&quot;label\&quot;: \&quot;mykey\&quot;,             \&quot;type\&quot;: \&quot;deploy_key\&quot;,             \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,             \&quot;repository\&quot;: {                 \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,                 \&quot;name\&quot;: \&quot;test\&quot;,                 \&quot;type\&quot;: \&quot;repository\&quot;,                 \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;             },             \&quot;links\&quot;:{                 \&quot;self\&quot;:{                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/123\&quot;                 }             }             \&quot;last_used\&quot;: null,             \&quot;comment\&quot;: \&quot;mleu@C02W454JHTD8\&quot;         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDeployKeysGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEPLOY_KEYS_KEY_ID":
        /*



Returns the deploy key belonging to a specific key.  Example: &#x60;&#x60;&#x60; $ curl -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-key/1234  Output: {     \&quot;comment\&quot;: \&quot;mleu@C02W454JHTD8\&quot;,     \&quot;last_used\&quot;: null,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-key/1234\&quot;         }     },     \&quot;repository\&quot;: {         \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,         \&quot;name\&quot;: \&quot;test\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;label\&quot;: \&quot;mykey\&quot;,     \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,     \&quot;id\&quot;: 1234,     \&quot;type\&quot;: \&quot;deploy_key\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API keyId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES":
        /*



Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../meta/filtering) for more details.


      Function parameters for this API opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE":
        /*



Returns a paginated list of all repositories owned by the specified account or UUID.  The result can be narrowed down based on the authenticated user&#39;s role.  E.g. with &#x60;?role&#x3D;contributor&#x60;, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../meta/filtering) for more details.


      Function parameters for this API workspace,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES_BUILD_KEY":
        /*



Returns the specified build status for a commit.


      Function parameters for this API node,key,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES":
        /*



Returns all statuses (e.g. build results) for a specific commit.


      Function parameters for this API node,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_FILEHISTORY_NODE_PATH":
        /*



Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;      $ hg log --follow &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](../../../../../../meta/filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.


      Function parameters for this API node,path,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugFilehistoryNodePathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_FORKS":
        /*



Returns a paginated list of all the forks of the specified repository.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugForksGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG":
        /*



Returns the object describing this repository.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS":
        /*



Returns a paginated list of webhooks installed on this repository.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS_UID":
        /*



Returns the webhook with the specified id installed on the specified repository.


      Function parameters for this API workspace,repoSlug,uid
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksUidGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_STATUSES":
        /*



Returns all statuses (e.g. build results) for the given pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_SRC":
        /*



This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{node}/{path}](src/%7Bnode%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugSrcGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_SRC_NODE_PATH":
        /*



This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  ## Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  ## File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   ## Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  ## Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](../../../../../../meta/filtering) for more details.


      Function parameters for this API node,path,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugSrcNodePathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_WATCHERS":
        /*



Returns a paginated list of all the watchers on the specified repository.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugWatchersGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USER_PERMISSIONS_REPOSITORIES":
        /*



Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between direct and indirect privileges.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../meta/filtering) by repository or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;repository.name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.


      Function parameters for this API opts
        */
        return new Promise((resolve, reject) => {
          this.userPermissionsRepositoriesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_FILES_PATH":
        /*



Convenience resource for getting to a snippet&#39;s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.


      Function parameters for this API path,encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdFilesPathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DIFFSTAT_SPEC":
        /*



Returns the diff stat for the specified commit.  Diff stat responses contain a record for every path modified by the commit and lists the number of lines added and removed for each file.   Example: &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964 {     \&quot;pagelen\&quot;: 500,     \&quot;values\&quot;: [         {             \&quot;type\&quot;: \&quot;diffstat\&quot;,             \&quot;status\&quot;: \&quot;modified\&quot;,             \&quot;lines_removed\&quot;: 1,             \&quot;lines_added\&quot;: 2,             \&quot;old\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\&quot;                     }                 }             },             \&quot;new\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\&quot;                     }                 }             }         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;


      Function parameters for this API spec,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDiffstatSpecGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_EXPORT_REPO_NAME_ISSUES_TASK_ID_ZIP":
        /*



This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 200 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, this endpoint&#39;s response is:  {  \&quot;type\&quot;: \&quot;issue_job_status\&quot;,  \&quot;status\&quot;: \&quot;ACCEPTED\&quot;,  \&quot;phase\&quot;: \&quot;Initializing\&quot;,  \&quot;total\&quot;: 0,  \&quot;count\&quot;: 0,  \&quot;pct\&quot;: 0 }   Then once it starts running, it becomes:  {  \&quot;type\&quot;: \&quot;issue_job_status\&quot;,  \&quot;status\&quot;: \&quot;STARTED\&quot;,  \&quot;phase\&quot;: \&quot;Attachments\&quot;,  \&quot;total\&quot;: 15,  \&quot;count\&quot;: 11,  \&quot;pct\&quot;: 73 }  Once the job has successfully completed, it returns a stream of the zip file.


      Function parameters for this API workspace,repoSlug,repoName,taskId
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_IMPORT":
        /*



When using GET, this endpoint reports the status of the current import task. Request example:  &#x60;&#x60;&#x60; $ curl -u &lt;username&gt; -X GET https://api.bitbucket.org/2.0/repositories/&lt;owner_username&gt;/&lt;repo_slug&gt;/issues/import &#x60;&#x60;&#x60;  After the job has been scheduled, but before it starts executing, this endpoint&#39;s response is:  &#x60;&#x60;&#x60; &lt; HTTP/1.1 202 Accepted {     \&quot;type\&quot;: \&quot;issue_job_status\&quot;,     \&quot;status\&quot;: \&quot;PENDING\&quot;,     \&quot;phase\&quot;: \&quot;Attachments\&quot;,     \&quot;total\&quot;: 15,     \&quot;count\&quot;: 0,     \&quot;percent\&quot;: 0 } &#x60;&#x60;&#x60;  Once it starts running, it is a 202 response with status STARTED and progress filled.  After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesImportGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PIPELINES_PIPELINE_UUID_STEPS_STEP_UUID_LOGS_LOG_UUID":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidLogsLogUuidGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PIPELINES_PIPELINE_UUID_STEPS_STEP_UUID_TEST_REPORTS":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PIPELINES_PIPELINE_UUID_STEPS_STEP_UUID_TEST_REPORTS_TEST_CASES":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PIPELINES_PIPELINE_UUID_STEPS_STEP_UUID_TEST_REPORTS_TEST_CASES_TEST_CASE_UUID_TEST_CASE_REASONS":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesTestCaseUuidTestCaseReasonsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_PERMISSIONS":
        /*



Returns an object for each team permission a user on the team has.  Permissions returned are effective permissions  if a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * &#x60;admin&#x60; * &#x60;collaborator&#x60;  Only users with admin permission for the team may access this resource.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;type\&quot;: \&quot;team_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;team\&quot;: {         \&quot;display_name\&quot;: \&quot;Atlassian Bitbucket\&quot;,         \&quot;uuid\&quot;: \&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;       }     },     {       \&quot;permission\&quot;: \&quot;collaborator\&quot;,       \&quot;type\&quot;: \&quot;team_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;seanaty\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;       },       \&quot;team\&quot;: {         \&quot;display_name\&quot;: \&quot;Atlassian Bitbucket\&quot;,         \&quot;uuid\&quot;: \&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../meta/filtering) by team, user, or permission by adding the following query string parameters:  * &#x60;q&#x3D;user.uuid&#x3D;\&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;&#x60; or &#x60;q&#x3D;permission&#x3D;\&quot;admin\&quot;&#x60; * &#x60;sort&#x3D;team.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.


      Function parameters for this API username,opts
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernamePermissionsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_PERMISSIONS_REPOSITORIES":
        /*



Returns an object for each repository permission for all of a teams repositories.  If the username URL parameter refers to a user account instead of a team account, an object containing the repository permissions of all the username&#39;s repositories will be returned.  Permissions returned are effective permissions  the highest level of permission the user has. This does not include public repositories that users are not granted any specific permission in, and does not distinguish between direct and indirect privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     },     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../../meta/filtering) by repository, user, or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;user.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.


      Function parameters for this API username,opts
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernamePermissionsRepositoriesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_PERMISSIONS_REPOSITORIES_REPO_SLUG":
        /*



Returns an object for each repository permission of a given repository.  If the username URL parameter refers to a user account instead of a team account, an object containing the repository permissions of the username&#39;s repository will be returned.  Permissions returned are effective permissions  the highest level of permission the user has. This does not include public repositories that users are not granted any specific permission in, and does not distinguish between direct and indirect privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions/repositories/geordi  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     },     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../../meta/filtering) by user, or permission by adding the following query string parameters:  * &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;user.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.


      Function parameters for this API username,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernamePermissionsRepositoriesRepoSlugGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USER_PERMISSIONS_TEAMS":
        /*



Returns an object for each team the caller is a member of, and their effective role  the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * &#x60;admin&#x60; * &#x60;collaborator&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/teams  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;type\&quot;: \&quot;team_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;team\&quot;: {         \&quot;display_name\&quot;: \&quot;Atlassian Bitbucket\&quot;,         \&quot;uuid\&quot;: \&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../meta/filtering) by team or permission by adding the following query string parameters:  * &#x60;q&#x3D;team.uuid&#x3D;\&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;&#x60; or &#x60;q&#x3D;permission&#x3D;\&quot;admin\&quot;&#x60; * &#x60;sort&#x3D;team.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.


      Function parameters for this API opts
        */
        return new Promise((resolve, reject) => {
          this.userPermissionsTeamsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "ADDON_LINKERS":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "ADDON_LINKERS_LINKER_KEY":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "ADDON_LINKERS_LINKER_KEY_VALUES":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyValuesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON_LINKERS_LINKER_KEY_VALUES_GE":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyValuesGet_0(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_DEPLOYMENT_VARIAB":
        /*



Find deployment environment level variables.


      Function parameters for this API username,repoSlug,environmentUuid
        */
        return new Promise((resolve, reject) => {
          this.getDeploymentVariables(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_FOR_REPOSIT":
        /*



Retrieve a specified pipeline


      Function parameters for this API username,repoSlug,pipelineUuid
        */
        return new Promise((resolve, reject) => {
          this.getPipelineForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_STEP_FOR_REPOSIT":
        /*



Retrieve a given step of a pipeline.


      Function parameters for this API username,repoSlug,pipelineUuid,stepUuid
        */
        return new Promise((resolve, reject) => {
          this.getPipelineStepForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_STEP_LOG_FOR_REPOSIT":
        /*



Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.


      Function parameters for this API username,repoSlug,pipelineUuid,stepUuid
        */
        return new Promise((resolve, reject) => {
          this.getPipelineStepLogForRepository(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_PIPELINE_STEPS_FOR_REPOSIT":
        /*



Find steps for the given pipeline.


      Function parameters for this API username,repoSlug,pipelineUuid
        */
        return new Promise((resolve, reject) => {
          this.getPipelineStepsForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_VARIABLE_FOR_T":
        /*



Retrieve a team level variable.


      Function parameters for this API username,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.getPipelineVariableForTeam(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_VARIABLE_FOR_U":
        /*



Retrieve a user level variable.


      Function parameters for this API username,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.getPipelineVariableForUser(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_VARIABLES_FOR_T":
        /*



Find account level variables.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.getPipelineVariablesForTeam(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINE_VARIABLES_FOR_U":
        /*



Find user level variables.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.getPipelineVariablesForUser(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PIPELINES_FOR_REPOSIT":
        /*



Find pipelines


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getPipelinesForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_REPOSITORY_PIPELINE_CON":
        /*



Retrieve the repository pipelines configuration.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineConfig(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_REPOSITORY_PIPELINE_KNOWN_H":
        /*



Retrieve a repository level known host.


      Function parameters for this API username,repoSlug,knownHostUuid
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineKnownHost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_REPOSITORY_PIPELINE_KNOWN_HO":
        /*



Find repository level known hosts.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineKnownHosts(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_REPOSITORY_PIPELINE_SCHED":
        /*



Retrieve a schedule by its UUID.


      Function parameters for this API username,repoSlug,scheduleUuid
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineSchedule(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_REPOSITORY_PIPELINE_SCHEDULE_EXECUTI":
        /*



Retrieve the executions of a given schedule.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineScheduleExecutions(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_REPOSITORY_PIPELINE_SCHEDU":
        /*



Retrieve the configured schedules for the given repository.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineSchedules(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_REPOSITORY_PIPELINE_SSH_KEY_P":
        /*



Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineSshKeyPair(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_REPOSITORY_PIPELINE_VARIA":
        /*



Retrieve a repository level variable.


      Function parameters for this API username,repoSlug,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineVariable(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_REPOSITORY_PIPELINE_VARIAB":
        /*



Find repository level variables.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getRepositoryPipelineVariables(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMPONENTS_COMPONENT_ID":
        /*



Returns the specified issue tracker component object.


      Function parameters for this API componentId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugComponentsComponentIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMPONENTS":
        /*



Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugComponentsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES":
        /*



Returns the issues in the issue tracker.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_ATTACHMENTS":
        /*



Returns all attachments for this issue.  This returns the files&#39; meta data. This does not return the files&#39; actual contents.  The files are always ordered by their upload date.


      Function parameters for this API workspace,repoSlug,issueId
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_ATTACHMENTS_PATH":
        /*



Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.


      Function parameters for this API path,issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_CHANGES_CHANGE_ID":
        /*



Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.


      Function parameters for this API changeId,issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_CHANGES":
        /*



Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the &#x60;/issues/123/changes&#x60; endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .  {   \&quot;pagelen\&quot;: 20,   \&quot;values\&quot;: [     {       \&quot;changes\&quot;: {         \&quot;priority\&quot;: {           \&quot;new\&quot;: \&quot;trivial\&quot;,           \&quot;old\&quot;: \&quot;major\&quot;         },         \&quot;assignee\&quot;: {           \&quot;new\&quot;: \&quot;\&quot;,           \&quot;old\&quot;: \&quot;evzijst\&quot;         },         \&quot;assignee_account_id\&quot;: {           \&quot;new\&quot;: \&quot;\&quot;,           \&quot;old\&quot;: \&quot;557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\&quot;         },         \&quot;kind\&quot;: {           \&quot;new\&quot;: \&quot;enhancement\&quot;,           \&quot;old\&quot;: \&quot;bug\&quot;         }       },       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/dogslow/issues/1#comment-2\&quot;         }       },       \&quot;issue\&quot;: {         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1\&quot;           }         },         \&quot;type\&quot;: \&quot;issue\&quot;,         \&quot;id\&quot;: 1,         \&quot;repository\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/dogslow\&quot;             },             \&quot;avatar\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/dogslow/avatar/32/\&quot;             }           },           \&quot;type\&quot;: \&quot;repository\&quot;,           \&quot;name\&quot;: \&quot;dogslow\&quot;,           \&quot;full_name\&quot;: \&quot;evzijst/dogslow\&quot;,           \&quot;uuid\&quot;: \&quot;{988b17c6-1a47-4e70-84ee-854d5f012bf6}\&quot;         },         \&quot;title\&quot;: \&quot;Updated title\&quot;       },       \&quot;created_on\&quot;: \&quot;2018-03-03T00:35:28.353630+00:00\&quot;,       \&quot;user\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;evzijst\&quot;,         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;uuid\&quot;: \&quot;{aaa7972b-38af-4fb1-802d-6e3854c95778}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/account/evzijst/avatar/32/\&quot;           }         }       },       \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Removed assignee, changed kind and priority.\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Removed assignee, changed kind and priority.&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;       },       \&quot;type\&quot;: \&quot;issue_change\&quot;,       \&quot;id\&quot;: 2     }   ],   \&quot;page\&quot;: 1 } &#x60;&#x60;&#x60;  Changes support [filtering and sorting](../../../meta/filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \&quot;resolved\&quot;:  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode&#x3D;&#39;q&#x3D;changes.state.new &#x3D; \&quot;resolved\&quot;&#39; &#x60;&#x60;&#x60;  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The &#x60;changes.assignee&#x60; and &#x60;changes.assignee_account_id&#x60; fields are not a &#x60;user&#x60; object. Instead, they contain the raw &#x60;username&#x60; and &#x60;account_id&#x60; of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The &#x60;changes.assignee&#x60; field is deprecated will disappear in the future. Use &#x60;changes.assignee_account_id&#x60; instead.


      Function parameters for this API issueId,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_COMMENTS_COMMENT_ID":
        /*



Returns the specified issue comment object.


      Function parameters for this API commentId,workspace,username,repoSlug,issueId
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_COMMENTS":
        /*



Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.


      Function parameters for this API issueId,workspace,username,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID":
        /*



Returns the specified issue.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_VOTE":
        /*



Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven&#39;t.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_WATCH":
        /*



Indicated whether or not the authenticated user is watching this issue.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_MILESTONES":
        /*



Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugMilestonesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_MILESTONES_MILESTONE_ID":
        /*



Returns the specified issue tracker milestone object.


      Function parameters for this API milestoneId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_VERSIONS":
        /*



Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugVersionsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_VERSIONS_VERSION_ID":
        /*



Returns the specified issue tracker version object.


      Function parameters for this API versionId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugVersionsVersionIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCH_RESTRICTIONS":
        /*



Returns a paginated list of all branch restrictions on the repository.


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchRestrictionsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCH_RESTRICTIONS_ID":
        /*



Returns a specific branch restriction rule.


      Function parameters for this API id,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS":
        /*



Returns all the teams that the authenticated user is associated with.


      Function parameters for this API opts
        */
        return new Promise((resolve, reject) => {
          this.teamsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_FOLLOWERS":
        /*



Returns the list of accounts that are following this team.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameFollowersGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_FOLLOWING":
        /*



Returns the list of accounts this team is following.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameFollowingGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME":
        /*



Gets the public information associated with a team.  If the team&#39;s profile is private, &#x60;location&#x60;, &#x60;website&#x60; and &#x60;created_on&#x60; elements are omitted.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_HOOKS":
        /*



Returns a paginated list of webhooks installed on this team.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_HOOKS_UID":
        /*



Returns the webhook with the specified id installed on the given team account.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksUidGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_MEMBERS":
        /*



Returns all members of the specified team. Any member of any of the team&#39;s groups is considered a member of the team. This includes users in groups that may not actually have access to any of the team&#39;s repositories.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameMembersGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_REPOSITORIES":
        /*



All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameRepositoriesGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_MEMBERS":
        /*



Returns all members of the specified team. Any member of any of the team&#39;s groups is considered a member of the team. This includes users in groups that may not actually have access to any of the team&#39;s repositories.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameMembersGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_REPOSITORIES":
        /*



All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameRepositoriesGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS":
        /*



Returns all snippets. Like pull requests, repositories and teams, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by the current user, but also all snippets owned by any of the teams the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the &#x60;?role&#x3D;[owner|contributor|member]&#x60; query parameter where the roles are defined as follows:  * &#x60;owner&#x60;: all snippets owned by the current user * &#x60;contributor&#x60;: all snippets owned by, or watched by the current user * &#x60;member&#x60;: owned by the user, their teams, or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports &#x60;application/json&#x60; responses and no &#x60;multipart/form-data&#x60; or &#x60;multipart/related&#x60;. As a result, it is not possible to include the file contents.


      Function parameters for this API opts
        */
        return new Promise((resolve, reject) => {
          this.snippetsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMENTS_COMMENT_ID":
        /*



Returns the specific snippet comment.


      Function parameters for this API commentId,encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommentsCommentIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMENTS":
        /*



Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.


      Function parameters for this API encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommentsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMITS":
        /*



Returns the changes (commits) made on this snippet.


      Function parameters for this API encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommitsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMITS_REVISION":
        /*




      Function parameters for this API encodedId,workspace,revision
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommitsRevisionGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID":
        /*



Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is &#x60;application/json&#x60;. Since JSON is always &#x60;utf-8&#x60;, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the &#x60;Accept: multipart/related&#x60; HTTP request header.      $ curl -H \&quot;Accept: multipart/related\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj\&quot;         },         \&quot;comments\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\&quot;         },         \&quot;watchers\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\&quot;         },         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\&quot;         }       },       \&quot;id\&quot;: kypj,       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;created_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;updated_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;is_private\&quot;: false,       \&quot;files\&quot;: {         \&quot;foo.txt\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\&quot;             }           }         },         \&quot;image.png\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-image.png\&quot;             }           }         }       ],       \&quot;owner\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       },       \&quot;creator\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  multipart/form-data -------------------  As with creating new snippets, &#x60;multipart/form-data&#x60; can be used as an alternative to &#x60;multipart/related&#x60;. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like &#x60;links&#x60; are omitted:      $ curl -H \&quot;Accept: multipart/form-data\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;     Content-Type: text/plain; charset&#x3D;\&quot;utf-8\&quot;      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     ------------------------------5957323a6b76--


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_NODE_ID_FILES_PATH":
        /*



Retrieves the raw contents of a specific file in the snippet. The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to avoid issues with malevolent executable files.  The file&#39;s mime type is derived from its filename and returned in the &#x60;Content-Type&#x60; header.  Note that for text files, no character encoding is included as part of the content type.


      Function parameters for this API path,nodeId,encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdNodeIdFilesPathGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_NODE_ID":
        /*



Identical to &#x60;GET /snippets/encoded_id&#x60;, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while &#x60;/snippets/encoded_id&#x60; always returns the snippet&#39;s current revision.  Note that only the snippet&#39;s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.


      Function parameters for this API workspace,encodedId,nodeId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdNodeIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_REVISION_DIFF":
        /*



Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;patch&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git and Mercurial do not track this, making it hard for Bitbucket to reliably determine this.


      Function parameters for this API workspace,encodedId,revision,opts
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdRevisionDiffGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_REVISION_PATCH":
        /*



Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;diff&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git and Mercurial do not track this, making it hard for Bitbucket to reliably determine this.


      Function parameters for this API workspace,encodedId,revision
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdRevisionPatchGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_WATCH":
        /*



Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdWatchGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_WATCHERS":
        /*



Returns a paginated list of all users watching a specific snippet.


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdWatchersGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE":
        /*



Identical to &#x60;/snippets&#x60;, except that the result is further filtered by the snippet owner and only those that are owned by &#x60;{workspace}&#x60; are returned.


      Function parameters for this API workspace,username,opts
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_PULLREQUESTS_FOR_COM":
        /*

Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when &#39;Go to pull request&#39; is clicked from the web interface for a commit&#39;s details.


      Function parameters for this API username,repoSlug,commit,opts
        */
        return new Promise((resolve, reject) => {
          this.getPullrequestsForCommit(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "PULLREQUESTS_SELECTED_USER":
        /*



Returns all pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the &#x60;state&#x60; query parameter. To retrieve pull requests that are in one of multiple states, repeat the &#x60;state&#x60; parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.


      Function parameters for this API selectedUser,opts
        */
        return new Promise((resolve, reject) => {
          this.pullrequestsSelectedUserGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEFAULT_REVIEWERS":
        /*



Returns the repository&#39;s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDefaultReviewersGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEFAULT_REVIEWERS_TARGET_USERNAME":
        /*



Returns the specified reviewer.  This can be used to test whether a user is among the repository&#39;s default reviewers list. A 404 indicates that that specified user is not a default reviewer.


      Function parameters for this API targetUsername,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_ACTIVITY":
        /*



Returns a paginated list of the pull request&#39;s activity log.  This includes comments that were made by the reviewers, updates and approvals.  Comments created on a file or a line of code have an inline property.  Comment example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;comment\&quot;: {                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\&quot;                     }                 },                 \&quot;deleted\&quot;: false,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;content\&quot;: {                     \&quot;raw\&quot;: \&quot;inline with to a dn from lines\&quot;,                     \&quot;markup\&quot;: \&quot;markdown\&quot;,                     \&quot;html\&quot;: \&quot;&lt;p&gt;inline with to a dn from lines&lt;/p&gt;\&quot;,                     \&quot;type\&quot;: \&quot;rendered\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;updated_on\&quot;: \&quot;2019-09-27T00:33:46.055384+00:00\&quot;,                 \&quot;inline\&quot;: {                     \&quot;context_lines\&quot;: \&quot;\&quot;,                     \&quot;to\&quot;: null,                     \&quot;path\&quot;: \&quot;\&quot;,                     \&quot;outdated\&quot;: false,                     \&quot;from\&quot;: 211                 },                 \&quot;type\&quot;: \&quot;pullrequest_comment\&quot;,                 \&quot;id\&quot;: 118571088             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;update\&quot;: {                 \&quot;description\&quot;: \&quot;\&quot;,                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;,                 \&quot;destination\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;6a2c16e4a152\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;master\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;reason\&quot;: \&quot;\&quot;,                 \&quot;source\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;728c8bad1813\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;username/NONE-add-onClick-prop-for-accessibility\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;state\&quot;: \&quot;OPEN\&quot;,                 \&quot;author\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;date\&quot;: \&quot;2019-05-10T06:48:25.305565+00:00\&quot;             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Approval example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;approval\&quot;: {                 \&quot;date\&quot;: \&quot;2019-09-27T00:37:19.849534+00:00\&quot;,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 }             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsActivityGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS":
        /*



Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the &#x60;state&#x60; query parameter. To retrieve pull requests that are in one of multiple states, repeat the &#x60;state&#x60; parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_ACTIVITY":
        /*



Returns a paginated list of the pull request&#39;s activity log.  This includes comments that were made by the reviewers, updates and approvals.  Comments created on a file or a line of code have an inline property.  Comment example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;comment\&quot;: {                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\&quot;                     }                 },                 \&quot;deleted\&quot;: false,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;content\&quot;: {                     \&quot;raw\&quot;: \&quot;inline with to a dn from lines\&quot;,                     \&quot;markup\&quot;: \&quot;markdown\&quot;,                     \&quot;html\&quot;: \&quot;&lt;p&gt;inline with to a dn from lines&lt;/p&gt;\&quot;,                     \&quot;type\&quot;: \&quot;rendered\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;updated_on\&quot;: \&quot;2019-09-27T00:33:46.055384+00:00\&quot;,                 \&quot;inline\&quot;: {                     \&quot;context_lines\&quot;: \&quot;\&quot;,                     \&quot;to\&quot;: null,                     \&quot;path\&quot;: \&quot;\&quot;,                     \&quot;outdated\&quot;: false,                     \&quot;from\&quot;: 211                 },                 \&quot;type\&quot;: \&quot;pullrequest_comment\&quot;,                 \&quot;id\&quot;: 118571088             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;update\&quot;: {                 \&quot;description\&quot;: \&quot;\&quot;,                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;,                 \&quot;destination\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;6a2c16e4a152\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;master\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;reason\&quot;: \&quot;\&quot;,                 \&quot;source\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;728c8bad1813\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;username/NONE-add-onClick-prop-for-accessibility\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;state\&quot;: \&quot;OPEN\&quot;,                 \&quot;author\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;date\&quot;: \&quot;2019-05-10T06:48:25.305565+00:00\&quot;             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Approval example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;approval\&quot;: {                 \&quot;date\&quot;: \&quot;2019-09-27T00:37:19.849534+00:00\&quot;,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 }             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_COMMENTS_COMMENT_ID":
        /*



Returns a specific pull request comment.


      Function parameters for this API pullRequestId,commentId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_COMMENTS":
        /*



Returns a paginated list of the pull request&#39;s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.


      Function parameters for this API workspace,repoSlug,pullRequestId
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_COMMITS":
        /*



Returns a paginated list of the pull request&#39;s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_DIFF":
        /*



Redirects to the [repository diff](../../diff/%7Bspec%7D) with the revspec that corresponds to the pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_DIFFSTAT":
        /*



Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D) with the revspec that corresponds to the pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID":
        /*



Returns the specified pull request.


      Function parameters for this API workspace,repoSlug,pullRequestId
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_PATCH":
        /*




      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_STATUSES":
        /*



Returns all statuses (e.g. build results) for the given pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SEARCH_ACCO":
        /*

Search for code in the repositories of the specified team


      Function parameters for this API username,searchQuery,opts
        */
        return new Promise((resolve, reject) => {
          this.searchAccount(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SEARCH_ACCOUN":
        /*

Search for code in the repositories of the specified user


      Function parameters for this API username,searchQuery,opts
        */
        return new Promise((resolve, reject) => {
          this.searchAccount_0(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DOWNLOADS_FILENAME":
        /*



Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact&#39;s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World


      Function parameters for this API filename,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDownloadsFilenameGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DOWNLOADS":
        /*



Returns a list of download links associated with the repository.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDownloadsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_COMMENTS_COMMENT_ID":
        /*



Returns the specified commit comment.


      Function parameters for this API node,commentId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIdGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_COMMENTS":
        /*



Returns the commit&#39;s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.


      Function parameters for this API node,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeCommentsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE":
        /*



Returns the specified commit.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1 {     \&quot;rendered\&quot;: {         \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;         }     },     \&quot;hash\&quot;: \&quot;f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;,     \&quot;repository\&quot;: {         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;links\&quot;: {             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi\&quot;             },             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts&#x3D;1730260\&quot;             }         },         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\&quot;         },         \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\&quot;         },         \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\&quot;         }     },     \&quot;author\&quot;: {         \&quot;raw\&quot;: \&quot;Brodie Rao &lt;a@b.c&gt;\&quot;,         \&quot;type\&quot;: \&quot;author\&quot;,         \&quot;user\&quot;: {             \&quot;display_name\&quot;: \&quot;Brodie Rao\&quot;,             \&quot;uuid\&quot;: \&quot;{9484702e-c663-4afd-aefb-c93a8cd31c28}\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\&quot;                 },                 \&quot;avatar\&quot;: {                     \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\&quot;                 }             },             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;nickname\&quot;: \&quot;brodie\&quot;,             \&quot;account_id\&quot;: \&quot;557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\&quot;         }     },     \&quot;summary\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;     },     \&quot;participants\&quot;: [],     \&quot;parents\&quot;: [         {             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;hash\&quot;: \&quot;f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 }             }         }     ],     \&quot;date\&quot;: \&quot;2012-07-16T19:37:54+00:00\&quot;,     \&quot;message\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API node,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMITS":
        /*



These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60; and &#x60;hg log&#x60;. Like these tools, the DAG can be filtered.  ## GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60; and &#x60;hg log&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on rev &#x60;master&#x60; (similar to &#x60;git log master&#x60;, &#x60;hg log master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/dev?exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMITS_REVISION":
        /*



These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60; and &#x60;hg log&#x60;. Like these tools, the DAG can be filtered.  ## GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60; and &#x60;hg log&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on rev &#x60;master&#x60; (similar to &#x60;git log master&#x60;, &#x60;hg log master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/dev?exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.


      Function parameters for this API revision,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitsRevisionGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DIFF_SPEC":
        /*



Produces a raw, git-style diff for either a single commit (diffed against its first parent), or a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a 3-way diff, or merge diff, is computed. This shows the changes introduced by the left branch (&#x60;3a8b42&#x60; in our example) as compared againt the right branch (&#x60;9ff173&#x60;).  This is equivalent to merging the left branch into the right branch and then computing the diff of the merge commit against its first parent (the right branch). This follows the same behavior as pull requests that also show this style of 3-way, or merge diff.  While similar to patches, diffs:  * Don&#39;t have a commit header (username, commit message, etc) * Support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter   the diff to just that one file diff  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.


      Function parameters for this API spec,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDiffSpecGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PATCH_SPEC":
        /*



Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (&#x60;3a8b42&#x60; and its ancestors in our example). For Mercurial, a single patch is returned that combines the changes of all commits on the source branch.  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the &#x60;path&#x3D;foo/bar.py&#x60; query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.


      Function parameters for this API spec,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPatchSpecGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "GET_DEPLOYMENT_FOR_REPOSIT":
        /*



Retrieve a deployment


      Function parameters for this API username,repoSlug,deploymentUuid
        */
        return new Promise((resolve, reject) => {
          this.getDeploymentForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_DEPLOYMENTS_FOR_REPOSIT":
        /*



Find deployments


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getDeploymentsForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_ENVIRONMENT_FOR_REPOSIT":
        /*



Retrieve an environment


      Function parameters for this API username,repoSlug,environmentUuid
        */
        return new Promise((resolve, reject) => {
          this.getEnvironmentForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "GET_ENVIRONMENTS_FOR_REPOSIT":
        /*



Find environments


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.getEnvironmentsForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "HOOK_EVENTS":
        /*



Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an &#x60;events&#x60; link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/hook_events  {     \&quot;repository\&quot;: {         \&quot;links\&quot;: {             \&quot;events\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/hook_events/repository\&quot;             }         }     },     \&quot;team\&quot;: {         \&quot;links\&quot;: {             \&quot;events\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/hook_events/team\&quot;             }         }     },     \&quot;user\&quot;: {         \&quot;links\&quot;: {             \&quot;events\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/hook_events/user\&quot;             }         }     } } &#x60;&#x60;&#x60;


      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.hookEventsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "HOOK_EVENTS_SUBJECT_TYPE":
        /*



Returns a paginated list of all valid webhook events for the specified entity.  This is public data that does not require any scopes or authentication.  Example:  NOTE: The following example is a truncated response object for the &#x60;team&#x60; &#x60;subject_type&#x60;. We return the same structure for the other &#x60;subject_type&#x60; objects.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/hook_events/team {     \&quot;page\&quot;: 1,     \&quot;pagelen\&quot;: 30,     \&quot;size\&quot;: 21,     \&quot;values\&quot;: [         {             \&quot;category\&quot;: \&quot;Repository\&quot;,             \&quot;description\&quot;: \&quot;Whenever a repository push occurs\&quot;,             \&quot;event\&quot;: \&quot;repo:push\&quot;,             \&quot;label\&quot;: \&quot;Push\&quot;         },         {             \&quot;category\&quot;: \&quot;Repository\&quot;,             \&quot;description\&quot;: \&quot;Whenever a repository fork occurs\&quot;,             \&quot;event\&quot;: \&quot;repo:fork\&quot;,             \&quot;label\&quot;: \&quot;Fork\&quot;         },         ...         {             \&quot;category\&quot;: \&quot;Repository\&quot;,             \&quot;description\&quot;: \&quot;Whenever a repository import occurs\&quot;,             \&quot;event\&quot;: \&quot;repo:imported\&quot;,             \&quot;label\&quot;: \&quot;Import\&quot;         }     ] } &#x60;&#x60;&#x60;


      Function parameters for this API subjectType
        */
        return new Promise((resolve, reject) => {
          this.hookEventsSubjectTypeGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS":
        /*



Returns a paginated list of webhooks installed on this repository.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS_UID":
        /*



Returns the webhook with the specified id installed on the specified repository.


      Function parameters for this API workspace,repoSlug,uid
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksUidGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS":
        /*



Returns a paginated list of webhooks installed on this team.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_HOOKS_UID":
        /*



Returns the webhook with the specified id installed on the given team account.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksUidGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS":
        /*



Returns a paginated list of webhooks installed on this user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS_UID":
        /*



Returns the webhook with the specified id installed on the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksUidGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_PROJECTS":
        /*




      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameProjectsGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_PROJECTS_PROJECT_KEY":
        /*




      Function parameters for this API username,projectKey
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameProjectsProjectKeyGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USERS_USERNAME_SSH_KEYS":
        /*



Returns a specific SSH public key belonging to a user.  Example: &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{fbe4bbab-f6f7-4dde-956b-5c58323c54b3}  {     \&quot;comment\&quot;: \&quot;user@myhost\&quot;,     \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,     \&quot;label\&quot;: \&quot;\&quot;,     \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;         }     },     \&quot;owner\&quot;: {         \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,         \&quot;links\&quot;: {             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;             },             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;             }         },         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;username\&quot;: \&quot;markadams-atl\&quot;,         \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,         \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;     },     \&quot;type\&quot;: \&quot;ssh_key\&quot;,     \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API username,keyId
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameSshKeysGet(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_SSH_KEYS_GE":
        /*



Returns a paginated list of the user&#39;s SSH public keys.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys {     \&quot;page\&quot;: 1,     \&quot;pagelen\&quot;: 10,     \&quot;size\&quot;: 1,     \&quot;values\&quot;: [         {             \&quot;comment\&quot;: \&quot;user@myhost\&quot;,             \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,             \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,             \&quot;label\&quot;: \&quot;\&quot;,             \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;                 }             },             \&quot;owner\&quot;: {                 \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,                 \&quot;links\&quot;: {                     \&quot;avatar\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;                     },                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;                     }                 },                 \&quot;type\&quot;: \&quot;user\&quot;,                 \&quot;username\&quot;: \&quot;markadams-atl\&quot;,                 \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,                 \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;             },             \&quot;type\&quot;: \&quot;ssh_key\&quot;,             \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot;         }     ] } &#x60;&#x60;&#x60;


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameSshKeysGet_0(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_BRANCHES":
        /*



Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches | jq . {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;heads\&quot;: [         {           \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,           \&quot;type\&quot;: \&quot;commit\&quot;,           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;             }           }         }       ],       \&quot;type\&quot;: \&quot;named_branch\&quot;,       \&quot;name\&quot;: \&quot;default\&quot;,       \&quot;links\&quot;: {         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default\&quot;         },         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/branch/default\&quot;         }       },       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,         \&quot;repository\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial\&quot;             },             \&quot;avatar\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/avatar/32/\&quot;             }           },           \&quot;type\&quot;: \&quot;repository\&quot;,           \&quot;name\&quot;: \&quot;mercurial\&quot;,           \&quot;full_name\&quot;: \&quot;seanfarley/mercurial\&quot;,           \&quot;uuid\&quot;: \&quot;{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\&quot;         },         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments\&quot;           },           \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve\&quot;           },           \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses\&quot;           }         },         \&quot;author\&quot;: {           \&quot;raw\&quot;: \&quot;Martin von Zweigbergk &lt;martinvonz@google.com&gt;\&quot;,           \&quot;type\&quot;: \&quot;author\&quot;,           \&quot;user\&quot;: {             \&quot;username\&quot;: \&quot;martinvonz\&quot;,             \&quot;nickname\&quot;: \&quot;martinvonz\&quot;,             \&quot;display_name\&quot;: \&quot;Martin von Zweigbergk\&quot;,             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;uuid\&quot;: \&quot;{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/martinvonz\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/martinvonz/\&quot;               },               \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/martinvonz/avatar/32/\&quot;               }             }           }         },         \&quot;parents\&quot;: [           {             \&quot;hash\&quot;: \&quot;5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;,             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;               }             }           }         ],         \&quot;date\&quot;: \&quot;2018-02-01T18:44:49+00:00\&quot;,         \&quot;message\&quot;: \&quot;config: replace a for-else by any()\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;       }     },     {       \&quot;heads\&quot;: [         {           \&quot;hash\&quot;: \&quot;1d60ad093792706e1dc7a52b20942593f2c19655\&quot;,           \&quot;type\&quot;: \&quot;commit\&quot;,           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;             }           }         }       ],       \&quot;type\&quot;: \&quot;named_branch\&quot;,       \&quot;name\&quot;: \&quot;stable\&quot;,       \&quot;links\&quot;: {         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/stable\&quot;         },         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/stable\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/branch/stable\&quot;         }       },       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;1d60ad093792706e1dc7a52b20942593f2c19655\&quot;,         \&quot;repository\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial\&quot;             },             \&quot;avatar\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/avatar/32/\&quot;             }           },           \&quot;type\&quot;: \&quot;repository\&quot;,           \&quot;name\&quot;: \&quot;mercurial\&quot;,           \&quot;full_name\&quot;: \&quot;seanfarley/mercurial\&quot;,           \&quot;uuid\&quot;: \&quot;{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\&quot;         },         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/comments\&quot;           },           \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/approve\&quot;           },           \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/statuses\&quot;           }         },         \&quot;author\&quot;: {           \&quot;raw\&quot;: \&quot;Augie Fackler &lt;raf@durin42.com&gt;\&quot;,           \&quot;type\&quot;: \&quot;author\&quot;,           \&quot;user\&quot;: {             \&quot;username\&quot;: \&quot;durin42\&quot;,             \&quot;nickname\&quot;: \&quot;durin42\&quot;,             \&quot;display_name\&quot;: \&quot;Augie Fackler\&quot;,             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;uuid\&quot;: \&quot;{e07dc61f-bb05-4218-b43a-d991f26be65a}\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/durin42\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/durin42/\&quot;               },               \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/durin42/avatar/32/\&quot;               }             }           }         },         \&quot;parents\&quot;: [           {             \&quot;hash\&quot;: \&quot;56a0da11bde519d79168e890df4bcf0da62f0a7b\&quot;,             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/56a0da11bde519d79168e890df4bcf0da62f0a7b\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/56a0da11bde519d79168e890df4bcf0da62f0a7b\&quot;               }             }           }         ],         \&quot;date\&quot;: \&quot;2018-02-01T19:13:41+00:00\&quot;,         \&quot;message\&quot;: \&quot;Added signature for changeset d334afc585e2\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Branches support [filtering and sorting](../../../../../meta/filtering) that can be used to search for specific branches. For instance, to find all branches that have \&quot;stab\&quot; in their name:  &#x60;&#x60;&#x60; curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches -G --data-urlencode &#39;q&#x3D;name ~ \&quot;stab\&quot;&#39; &#x60;&#x60;&#x60;  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \&quot;$ hg branches\&quot; or \&quot;$ git branch --list\&quot;. Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\&quot;v10\&quot;, \&quot;v11\&quot;, \&quot;v9\&quot;] instead of [\&quot;v9\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;].  Sorting can be changed using the ?q&#x3D; query parameter. When using ?q&#x3D;name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.


      Function parameters for this API workspace,username,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsBranchesGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_BRANCHES_NAME":
        /*



Returns a branch object within the specified repository.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default | jq . {   \&quot;heads\&quot;: [     {       \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,       \&quot;type\&quot;: \&quot;commit\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;         }       }     }   ],   \&quot;type\&quot;: \&quot;named_branch\&quot;,   \&quot;name\&quot;: \&quot;default\&quot;,   \&quot;links\&quot;: {     \&quot;commits\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default\&quot;     },     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default\&quot;     },     \&quot;html\&quot;: {       \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/branch/default\&quot;     }   },   \&quot;target\&quot;: {     \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,     \&quot;repository\&quot;: {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial\&quot;         },         \&quot;avatar\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/avatar/32/\&quot;         }       },       \&quot;type\&quot;: \&quot;repository\&quot;,       \&quot;name\&quot;: \&quot;mercurial\&quot;,       \&quot;full_name\&quot;: \&quot;seanfarley/mercurial\&quot;,       \&quot;uuid\&quot;: \&quot;{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\&quot;     },     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;comments\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments\&quot;       },       \&quot;patch\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;diff\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;approve\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve\&quot;       },       \&quot;statuses\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses\&quot;       }     },     \&quot;author\&quot;: {       \&quot;raw\&quot;: \&quot;Martin von Zweigbergk &lt;martinvonz@google.com&gt;\&quot;,       \&quot;type\&quot;: \&quot;author\&quot;,       \&quot;user\&quot;: {         \&quot;username\&quot;: \&quot;martinvonz\&quot;,         \&quot;nickname\&quot;: \&quot;martinvonz\&quot;,         \&quot;display_name\&quot;: \&quot;Martin von Zweigbergk\&quot;,         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;uuid\&quot;: \&quot;{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/martinvonz\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/martinvonz/\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/account/martinvonz/avatar/32/\&quot;           }         }       }     },     \&quot;parents\&quot;: [       {         \&quot;hash\&quot;: \&quot;5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;           }         }       }     ],     \&quot;date\&quot;: \&quot;2018-02-01T18:44:49+00:00\&quot;,     \&quot;message\&quot;: \&quot;config: replace a for-else by any()\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot;   } } &#x60;&#x60;&#x60;  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).  For Mercurial, the response will include an additional field that lists the open heads.


      Function parameters for this API name,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsBranchesNameGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS":
        /*



Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \&quot;$ git show-ref\&quot;. Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\&quot;branch1\&quot;, \&quot;branch10\&quot;, \&quot;branch2\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;, \&quot;v9\&quot;] instead of [\&quot;branch1\&quot;, \&quot;branch2\&quot;, \&quot;branch10\&quot;, \&quot;v9\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;].  Sorting can be changed using the ?sort&#x3D; query parameter. When using ?sort&#x3D;name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.


      Function parameters for this API workspace,username,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_TAGS":
        /*



Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \&quot;$ hg tags\&quot; or \&quot;$ git tag --list\&quot;. Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\&quot;v10\&quot;, \&quot;v11\&quot;, \&quot;v9\&quot;] instead of [\&quot;v9\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;].  Sorting can be changed using the ?sort&#x3D; query parameter. When using ?sort&#x3D;name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.


      Function parameters for this API workspace,username,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsTagsGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_TAGS_NAME":
        /*



Returns the specified tag.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \&quot;name\&quot;: \&quot;3.8\&quot;,   \&quot;links\&quot;: {     \&quot;commits\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\&quot;     },     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\&quot;     },     \&quot;html\&quot;: {       \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/commits/tag/3.8\&quot;     }   },   \&quot;tagger\&quot;: {     \&quot;raw\&quot;: \&quot;Matt Mackall &lt;mpm@selenic.com&gt;\&quot;,     \&quot;type\&quot;: \&quot;author\&quot;,     \&quot;user\&quot;: {       \&quot;username\&quot;: \&quot;mpmselenic\&quot;,       \&quot;nickname\&quot;: \&quot;mpmselenic\&quot;,       \&quot;display_name\&quot;: \&quot;Matt Mackall\&quot;,       \&quot;type\&quot;: \&quot;user\&quot;,       \&quot;uuid\&quot;: \&quot;{a4934530-db4c-419c-a478-9ab4964c2ee7}\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/mpmselenic\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/mpmselenic/\&quot;         },         \&quot;avatar\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/account/mpmselenic/avatar/32/\&quot;         }       }     }   },   \&quot;date\&quot;: \&quot;2016-05-01T18:52:25+00:00\&quot;,   \&quot;message\&quot;: \&quot;Added tag 3.8 for changeset f85de28eae32\&quot;,   \&quot;type\&quot;: \&quot;tag\&quot;,   \&quot;target\&quot;: {     \&quot;hash\&quot;: \&quot;f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;,     \&quot;repository\&quot;: {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg\&quot;         },         \&quot;avatar\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/avatar/32/\&quot;         }       },       \&quot;type\&quot;: \&quot;repository\&quot;,       \&quot;name\&quot;: \&quot;hg\&quot;,       \&quot;full_name\&quot;: \&quot;seanfarley/hg\&quot;,       \&quot;uuid\&quot;: \&quot;{c75687fb-e99d-4579-9087-190dbd406d30}\&quot;     },     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;comments\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\&quot;       },       \&quot;patch\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;diff\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;approve\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\&quot;       },       \&quot;statuses\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\&quot;       }     },     \&quot;author\&quot;: {       \&quot;raw\&quot;: \&quot;Sean Farley &lt;sean@farley.io&gt;\&quot;,       \&quot;type\&quot;: \&quot;author\&quot;,       \&quot;user\&quot;: {         \&quot;username\&quot;: \&quot;seanfarley\&quot;,         \&quot;nickname\&quot;: \&quot;seanfarley\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Farley\&quot;,         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;uuid\&quot;: \&quot;{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/seanfarley\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/account/seanfarley/avatar/32/\&quot;           }         }       }     },     \&quot;parents\&quot;: [       {         \&quot;hash\&quot;: \&quot;9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\&quot;           }         }       }     ],     \&quot;date\&quot;: \&quot;2016-05-01T04:21:17+00:00\&quot;,     \&quot;message\&quot;: \&quot;debian: alphabetize build deps\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot;   } } &#x60;&#x60;&#x60;


      Function parameters for this API name,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsTagsNameGet(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      default:
        throw ErrorHelper.getError(`Can't get entity`, 404);
    }
  }
  // This is a function for repositoriesWorkspaceRepoSlugFilehistoryNodePathGet
  /*


Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;      $ hg log --follow &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](../../../../../../meta/filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.

 */
  repositoriesWorkspaceRepoSlugFilehistoryNodePathGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SourceApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let path = "path_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'renames': "renames_example", // String |  When `true`, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying `false`.
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugFilehistoryNodePathGet(
      incomingOptions.node,
      incomingOptions.path,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugSrcGet
  /*


This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{node}/{path}](src/%7Bnode%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)

 */
  repositoriesWorkspaceRepoSlugSrcGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SourceApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'format': "format_example" // String | Instead of returning the file's contents, return the (json) meta data for it.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugSrcGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugSrcNodePathGet
  /*


This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  ## Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  ## File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   ## Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  ## Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](../../../../../../meta/filtering) for more details.

 */
  repositoriesWorkspaceRepoSlugSrcNodePathGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SourceApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let path = "path_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'format': "format_example", // String | If 'meta' is provided, returns the (json) meta data for the contents of the file.  If 'rendered' is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git and Mercurial do not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file's actual contents.
      //  'q': "q_example", // String | Optional filter expression as per [filtering and sorting](../../../../../../meta/filtering).
      //  'sort': "sort_example", // String | Optional sorting parameter as per [filtering and sorting](../../../../../../meta/filtering#query-sort).
      maxDepth: 56 // Number | If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugSrcNodePathGet(
      incomingOptions.node,
      incomingOptions.path,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchingModelGet
  /*


Return the branching model as applied to the repository. This view is read-only. The branching model settings can be changed using the [settings](branching-model/settings#get) API.  The returned object:  1. Always has a &#x60;development&#x60; property. &#x60;development.branch&#x60; contains    the actual repository branch object that is considered to be the    &#x60;development&#x60; branch. &#x60;development.branch&#x60; will not be present    if it does not exist. 2. Might have a &#x60;production&#x60; property. &#x60;production&#x60; will not    be present when &#x60;production&#x60; is disabled.    &#x60;production.branch&#x60; contains the actual branch object that is    considered to be the &#x60;production&#x60; branch. &#x60;production.branch&#x60; will    not be present if it does not exist. 3. Always has a &#x60;branch_types&#x60; array which contains all enabled branch    types.  Example body:  &#x60;&#x60;&#x60; {   \&quot;development\&quot;: {     \&quot;name\&quot;: \&quot;master\&quot;,     \&quot;branch\&quot;: {       \&quot;type\&quot;: \&quot;branch\&quot;,       \&quot;name\&quot;: \&quot;master\&quot;,       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;16dffcb0de1b22e249db6799532074cf32efe80f\&quot;       }     },     \&quot;use_mainbranch\&quot;: true   },   \&quot;production\&quot;: {     \&quot;name\&quot;: \&quot;production\&quot;,     \&quot;branch\&quot;: {       \&quot;type\&quot;: \&quot;branch\&quot;,       \&quot;name\&quot;: \&quot;production\&quot;,       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;16dffcb0de1b22e249db6799532074cf32efe80f\&quot;       }     },     \&quot;use_mainbranch\&quot;: false   },   \&quot;branch_types\&quot;: [     {       \&quot;kind\&quot;: \&quot;release\&quot;,       \&quot;prefix\&quot;: \&quot;release/\&quot;     },     {       \&quot;kind\&quot;: \&quot;hotfix\&quot;,       \&quot;prefix\&quot;: \&quot;hotfix/\&quot;     },     {       \&quot;kind\&quot;: \&quot;feature\&quot;,       \&quot;prefix\&quot;: \&quot;feature/\&quot;     },     {       \&quot;kind\&quot;: \&quot;bugfix\&quot;,       \&quot;prefix\&quot;: \&quot;bugfix/\&quot;     }   ],   \&quot;type\&quot;: \&quot;branching_model\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/.../branching-model\&quot;     }   } } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugBranchingModelGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchingModelApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugBranchingModelGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchingModelSettingsGet
  /*


Return the branching model configuration for a repository. The returned object:  1. Always has a &#x60;development&#x60; property for the development branch. 2. Always a &#x60;production&#x60; property for the production branch. The    production branch can be disabled. 3. The &#x60;branch_types&#x60; contains all the branch types.  This is the raw configuration for the branching model. A client wishing to see the branching model with its actual current branches may find the [active model API](../branching-model#get) more useful.  Example body:  &#x60;&#x60;&#x60; {   \&quot;development\&quot;: {     \&quot;is_valid\&quot;: true,     \&quot;name\&quot;: null,     \&quot;use_mainbranch\&quot;: true   },   \&quot;production\&quot;: {     \&quot;is_valid\&quot;: true,     \&quot;name\&quot;: \&quot;production\&quot;,     \&quot;use_mainbranch\&quot;: false,     \&quot;enabled\&quot;: false   },   \&quot;branch_types\&quot;: [     {       \&quot;kind\&quot;: \&quot;release\&quot;,       \&quot;enabled\&quot;: true,       \&quot;prefix\&quot;: \&quot;release/\&quot;     },     {       \&quot;kind\&quot;: \&quot;hotfix\&quot;,       \&quot;enabled\&quot;: true,       \&quot;prefix\&quot;: \&quot;hotfix/\&quot;     },     {       \&quot;kind\&quot;: \&quot;feature\&quot;,       \&quot;enabled\&quot;: true,       \&quot;prefix\&quot;: \&quot;feature/\&quot;     },     {       \&quot;kind\&quot;: \&quot;bugfix\&quot;,       \&quot;enabled\&quot;: false,       \&quot;prefix\&quot;: \&quot;bugfix/\&quot;     }   ],   \&quot;type\&quot;: \&quot;branching_model_settings\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/.../branching-model/settings\&quot;     }   } } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchingModelApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugBranchingModelSettingsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameRepositoriesGet
  /*


All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.

 */
  teamsUsernameRepositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameRepositoriesGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for userEmailsEmailGet
  /*


Returns details about a specific one of the authenticated user&#39;s email addresses.  Details describe whether the address has been confirmed by the user and whether it is the user&#39;s primary address or not.

 */
  userEmailsEmailGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String |
    /*let email = "email_example";*/ apiInstance.userEmailsEmailGet(
      incomingOptions.email,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for userEmailsGet
  /*


Returns all the authenticated user&#39;s email addresses. Both confirmed and unconfirmed.

 */
  userEmailsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi();
    apiInstance.userEmailsGet((error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for userGet
  /*


Returns the currently logged in user.

 */
  userGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi();
    apiInstance.userGet((error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for usersUsernameFollowersGet
  /*


Returns the list of accounts that are following this user.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.

 */
  usersUsernameFollowersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | The account's username
    /*let username = "username_example";*/ apiInstance.usersUsernameFollowersGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameFollowingGet
  /*


Returns the list of accounts this user is following.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.

 */
  usersUsernameFollowingGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | The user's username
    /*let username = "username_example";*/ apiInstance.usersUsernameFollowingGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameGet
  /*


Gets the public information associated with a user account.  If the user&#39;s profile is private, &#x60;location&#x60;, &#x60;website&#x60; and &#x60;created_on&#x60; elements are omitted.  Note that the user object returned by this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-bitbucket-user-objects) for details.

 */
  usersUsernameGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | The account's UUID, account_id, or username. Note that username has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
    /*let username = "username_example";*/ apiInstance.usersUsernameGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksGet
  /*


Returns a paginated list of webhooks installed on this user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameHooksGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksUidGet
  /*


Returns the webhook with the specified id installed on the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksUidGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id.
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.usersUsernameHooksUidGet(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameRepositoriesGet
  /*


All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.

 */
  usersUsernameRepositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameRepositoriesGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getCommitHostedPropertyValue
  /*


Retrieve an application property value stored against a commit.

 */
  getCommitHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The commit // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let commit = "commit_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.getCommitHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.commit,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for getPullRequestHostedPropertyValue
  /*


Retrieve an application property value stored against a pull request.

 */
  getPullRequestHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The pull request ID // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullrequestId = "pullrequestId_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.getPullRequestHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pullrequestId,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for getRepositoryHostedPropertyValue
  /*


Retrieve an application property value stored against a repository.

 */
  getRepositoryHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.getRepositoryHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for retrieveUserHostedPropertyValue
  /*


Retrieve an application property value stored against a user.

 */
  retrieveUserHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The user // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.retrieveUserHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet
  /*


Returns the specified build status for a commit.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitstatusesApi(); // String | The commit's SHA1 // String | The build status' unique ke // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let key = "key_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet(
      incomingOptions.node,
      incomingOptions.key,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesGet
  /*


Returns all statuses (e.g. build results) for a specific commit.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitstatusesApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesGet(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet
  /*


Returns all statuses (e.g. build results) for the given pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitstatusesApi(); // Number | The id of the pull request // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDeployKeysGet
  /*


Returns all deploy-keys belonging to a repository.  Example: &#x60;&#x60;&#x60; $ curl -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys  Output: {     \&quot;pagelen\&quot;: 10,     \&quot;values\&quot;: [         {             \&quot;id\&quot;: 123,             \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,             \&quot;label\&quot;: \&quot;mykey\&quot;,             \&quot;type\&quot;: \&quot;deploy_key\&quot;,             \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,             \&quot;repository\&quot;: {                 \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,                 \&quot;name\&quot;: \&quot;test\&quot;,                 \&quot;type\&quot;: \&quot;repository\&quot;,                 \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;             },             \&quot;links\&quot;:{                 \&quot;self\&quot;:{                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/123\&quot;                 }             }             \&quot;last_used\&quot;: null,             \&quot;comment\&quot;: \&quot;mleu@C02W454JHTD8\&quot;         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugDeployKeysGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DeployApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDeployKeysGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet
  /*


Returns the deploy key belonging to a specific key.  Example: &#x60;&#x60;&#x60; $ curl -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-key/1234  Output: {     \&quot;comment\&quot;: \&quot;mleu@C02W454JHTD8\&quot;,     \&quot;last_used\&quot;: null,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-key/1234\&quot;         }     },     \&quot;repository\&quot;: {         \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,         \&quot;name\&quot;: \&quot;test\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;label\&quot;: \&quot;mykey\&quot;,     \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,     \&quot;id\&quot;: 1234,     \&quot;type\&quot;: \&quot;deploy_key\&quot; } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DeployApi(); // String | The key ID matching the deploy key // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let keyId = "keyId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDeployKeysKeyIdGet(
      incomingOptions.keyId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesGet
  /*


Returns a paginated list of all public repositories.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../meta/filtering) for more details.

 */
  repositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi();
    let opts = {
      //  'after': "after_example" // String | Filter the results to include only repositories create on or after this [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601)  timestamp. Example: `YYYY-MM-DDTHH:mm:ss.sssZ`
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesGet(
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceGet
  /*


Returns a paginated list of all repositories owned by the specified account or UUID.  The result can be narrowed down based on the authenticated user&#39;s role.  E.g. with &#x60;?role&#x3D;contributor&#x60;, only those repositories that the authenticated user has write access to are returned (this includes any repo the user is an admin on, as that implies write access).  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../meta/filtering) for more details.

 */
  repositoriesWorkspaceGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let workspace = "workspace_example";*/ let opts = {
      page: 1 // Number | Page number of the current results. This is an optional element that is not provided in all responses.
      //  'role': "role_example" // String |  Filters the result based on the authenticated user's role on each repository.  * **member**: returns repositories to which the user has explicit read access * **contributor**: returns repositories to which the user has explicit write access * **admin**: returns repositories to which the user has explicit administrator access * **owner**: returns all repositories owned by the current user
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceGet(
      incomingOptions.workspace,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet
  /*


Returns the specified build status for a commit.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | The commit's SHA1 // String | The build status' unique ke // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let key = "key_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyGet(
      incomingOptions.node,
      incomingOptions.key,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesGet
  /*


Returns all statuses (e.g. build results) for a specific commit.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesGet(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugFilehistoryNodePathGet
  /*


Returns a paginated list of commits that modified the specified file.  Commits are returned in reverse chronological order. This is roughly equivalent to the following commands:      $ git log --follow --date-order &lt;sha&gt; &lt;path&gt;      $ hg log --follow &lt;path&gt;  By default, Bitbucket will follow renames and the path name in the returned entries reflects that. This can be turned off using the &#x60;?renames&#x3D;false&#x60; query parameter.  Results are returned in descending chronological order by default, and like most endpoints you can [filter and sort](../../../../../../meta/filtering) the response to only provide exactly the data you want.  For example, if you wanted to find commits made before 2011-05-18 against a file named &#x60;README.rst&#x60;, but you only wanted the path and date, your query would look like this:  &#x60;&#x60;&#x60; $ curl &#39;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst&#39;\\   &#39;?fields&#x3D;values.next,values.path,values.commit.date&amp;q&#x3D;commit.date&lt;&#x3D;2011-05-18&#39; {   \&quot;values\&quot;: [     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-17T07:32:09+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.rst\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:33:28+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     },     {       \&quot;commit\&quot;: {         \&quot;date\&quot;: \&quot;2011-05-16T06:15:39+00:00\&quot;       },       \&quot;path\&quot;: \&quot;README.txt\&quot;     }   ] } &#x60;&#x60;&#x60;  In the response you can see that the file was renamed to &#x60;README.rst&#x60; by the commit made on 2011-05-16, and was previously named &#x60;README.txt&#x60;.

 */
  repositoriesWorkspaceRepoSlugFilehistoryNodePathGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let path = "path_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'renames': "renames_example", // String |  When `true`, Bitbucket will follow the history of the file across renames (this is the default behavior). This can be turned off by specifying `false`.
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugFilehistoryNodePathGet(
      incomingOptions.node,
      incomingOptions.path,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugForksGet
  /*


Returns a paginated list of all the forks of the specified repository.

 */
  repositoriesWorkspaceRepoSlugForksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugForksGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugGet
  /*


Returns the object describing this repository.

 */
  repositoriesWorkspaceRepoSlugGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksGet
  /*


Returns a paginated list of webhooks installed on this repository.

 */
  repositoriesWorkspaceRepoSlugHooksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksUidGet
  /*


Returns the webhook with the specified id installed on the specified repository.

 */
  repositoriesWorkspaceRepoSlugHooksUidGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The installed webhook's id.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let uid = "uid_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksUidGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet
  /*


Returns all statuses (e.g. build results) for the given pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // Number | The id of the pull request // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugSrcGet
  /*


This endpoint redirects the client to the directory listing of the root directory on the main branch.  This is equivalent to directly hitting [/2.0/repositories/{username}/{repo_slug}/src/{node}/{path}](src/%7Bnode%7D/%7Bpath%7D) without having to know the name or SHA1 of the repo&#39;s main branch.  To create new commits, [POST to this endpoint](#post)

 */
  repositoriesWorkspaceRepoSlugSrcGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'format': "format_example" // String | Instead of returning the file's contents, return the (json) meta data for it.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugSrcGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugSrcNodePathGet
  /*


This endpoints is used to retrieve the contents of a single file, or the contents of a directory at a specified revision.  ## Raw file contents  When &#x60;path&#x60; points to a file, this endpoint returns the raw contents. The response&#39;s Content-Type is derived from the filename extension (not from the contents). The file contents are not processed and no character encoding/recoding is performed and as a result no character encoding is included as part of the Content-Type.  The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to prevent browsers from running executable files.  If the file is managed by LFS, then a 301 redirect pointing to Atlassian&#39;s media services platform is returned.  The response includes an ETag that is based on the contents of the file and its attributes. This means that an empty &#x60;__init__.py&#x60; always returns the same ETag, regardless on the directory it lives in, or the commit it is on.  ## File meta data  When the request for a file path includes the query parameter &#x60;?format&#x3D;meta&#x60;, instead of returning the file&#39;s raw contents, Bitbucket instead returns the JSON object describing the file&#39;s properties:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format&#x3D;meta {   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;     }   },   \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,   \&quot;commit\&quot;: {     \&quot;type\&quot;: \&quot;commit\&quot;,     \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;       }     }   },   \&quot;attributes\&quot;: [],   \&quot;type\&quot;: \&quot;commit_file\&quot;,   \&quot;size\&quot;: 0 } &#x60;&#x60;&#x60;  File objects contain an &#x60;attributes&#x60; element that contains a list of possible modifiers. Currently defined values are:  * &#x60;link&#x60; -- indicates that the entry is a symbolic link. The contents     of the file represent the path the link points to. * &#x60;executable&#x60; -- indicates that the file has the executable bit set. * &#x60;subrepository&#x60; -- indicates that the entry points to a submodule or     subrepo. The contents of the file is the SHA1 of the repository     pointed to. * &#x60;binary&#x60; -- indicates whether Bitbucket thinks the file is binary.  This endpoint can provide an alternative to how a HEAD request can be used to check for the existence of a file, or a file&#39;s size without incurring the overhead of receiving its full contents.   ## Directory listings  When &#x60;path&#x60; points to a directory instead of a file, the response is a paginated list of directory and file objects in the same order as the underlying SCM system would return them.  For example:  &#x60;&#x60;&#x60;javascript $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;path\&quot;: \&quot;tests/test_project\&quot;,       \&quot;type\&quot;: \&quot;commit_directory\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;         }       },       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       }     },     {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\&quot;         },         \&quot;meta\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format&#x3D;meta\&quot;         }       },       \&quot;path\&quot;: \&quot;tests/__init__.py\&quot;,       \&quot;commit\&quot;: {         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;hash\&quot;: \&quot;eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\&quot;           }         }       },       \&quot;attributes\&quot;: [],       \&quot;type\&quot;: \&quot;commit_file\&quot;,       \&quot;size\&quot;: 0     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  When listing the contents of the repo&#39;s root directory, the use of a trailing slash at the end of the URL is required.  The response by default is not recursive, meaning that only the direct contents of a path are returned. The response does not recurse down into subdirectories. In order to \&quot;walk\&quot; the entire directory tree, the client can either parse each response and follow the &#x60;self&#x60; links of each &#x60;commit_directory&#x60; object, or can specify a &#x60;max_depth&#x60; to recurse to.  The max_depth parameter will do a breadth-first search to return the contents of the subdirectories up to the depth specified. Breadth-first search was chosen as it leads to the least amount of file system operations for git. If the &#x60;max_depth&#x60; parameter is specified to be too large, the call will time out and return a 555.  Each returned object is either a &#x60;commit_file&#x60;, or a &#x60;commit_directory&#x60;, both of which contain a &#x60;path&#x60; element. This path is the absolute path from the root of the repository. Each object also contains a &#x60;commit&#x60; object which embeds the commit the file is on. Note that this is merely the commit that was used in the URL. It is *not* the commit that last modified the file.  Directory objects have 2 representations. Their &#x60;self&#x60; link returns the paginated contents of the directory. The &#x60;meta&#x60; link on the other hand returns the actual &#x60;directory&#x60; object itself, e.g.:  &#x60;&#x60;&#x60;javascript {   \&quot;path\&quot;: \&quot;tests/test_project\&quot;,   \&quot;type\&quot;: \&quot;commit_directory\&quot;,   \&quot;links\&quot;: {     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\&quot;     },     \&quot;meta\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format&#x3D;meta\&quot;     }   },   \&quot;commit\&quot;: { ... } } &#x60;&#x60;&#x60;  ## Querying, filtering and sorting  Like most API endpoints, this API supports the Bitbucket querying/filtering syntax and so you could filter a directory listing to only include entries that match certain criteria. For instance, to list all binary files over 1kb use the expression:  &#x60;size &gt; 1024 and attributes &#x3D; \&quot;binary\&quot;&#x60;  which after urlencoding yields the query string:  &#x60;?q&#x3D;size%3E1024+and+attributes%3D%22binary%22&#x60;  To change the ordering of the response, use the &#x60;?sort&#x60; parameter:  &#x60;.../src/eefd5ef/?sort&#x3D;-size&#x60;  See [filtering and sorting](../../../../../../meta/filtering) for more details.

 */
  repositoriesWorkspaceRepoSlugSrcNodePathGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let path = "path_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'format': "format_example", // String | If 'meta' is provided, returns the (json) meta data for the contents of the file.  If 'rendered' is provided, returns the contents of a non-binary file in HTML-formatted rendered markup. Since Git and Mercurial do not generally track what text encoding scheme is used, this endpoint attempts to detect the most appropriate character encoding. While usually correct, determining the character encoding can be ambiguous which in exceptional cases can lead to misinterpretation of the characters. As such, the raw element in the response object should not be treated as equivalent to the file's actual contents.
      //  'q': "q_example", // String | Optional filter expression as per [filtering and sorting](../../../../../../meta/filtering).
      //  'sort': "sort_example", // String | Optional sorting parameter as per [filtering and sorting](../../../../../../meta/filtering#query-sort).
      maxDepth: 56 // Number | If provided, returns the contents of the repository and its subdirectories recursively until the specified max_depth of nested directories. When omitted, this defaults to 1.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugSrcNodePathGet(
      incomingOptions.node,
      incomingOptions.path,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugWatchersGet
  /*


Returns a paginated list of all the watchers on the specified repository.

 */
  repositoriesWorkspaceRepoSlugWatchersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugWatchersGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for userPermissionsRepositoriesGet
  /*


Returns an object for each repository the caller has explicit access to and their effective permission  the highest level of permission the caller has. This does not return public repositories that the user was not granted any specific permission in, and does not distinguish between direct and indirect privileges.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../meta/filtering) by repository or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;repository.name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.

 */
  userPermissionsRepositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi();
    let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.userPermissionsRepositoriesGet(
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdFilesPathGet
  /*


Convenience resource for getting to a snippet&#39;s raw files without the need for first having to retrieve the snippet itself and having to pull out the versioned file links.

 */
  snippetsWorkspaceEncodedIdFilesPathGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let path = "path_example";*/ /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdFilesPathGet(
      incomingOptions.path,
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDiffstatSpecGet
  /*


Returns the diff stat for the specified commit.  Diff stat responses contain a record for every path modified by the commit and lists the number of lines added and removed for each file.   Example: &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diffstat/d222fa2..e174964 {     \&quot;pagelen\&quot;: 500,     \&quot;values\&quot;: [         {             \&quot;type\&quot;: \&quot;diffstat\&quot;,             \&quot;status\&quot;: \&quot;modified\&quot;,             \&quot;lines_removed\&quot;: 1,             \&quot;lines_added\&quot;: 2,             \&quot;old\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/e1749643d655d7c7014001a6c0f58abaf42ad850/setup.py\&quot;                     }                 }             },             \&quot;new\&quot;: {                 \&quot;path\&quot;: \&quot;setup.py\&quot;,                 \&quot;type\&quot;: \&quot;commit_file\&quot;,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/src/d222fa235229c55dad20b190b0b571adf737d5a6/setup.py\&quot;                     }                 }             }         }     ],     \&quot;page\&quot;: 1,     \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugDiffstatSpecGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | A commit SHA (e.g. `3a8b42`) or a commit range using double dot notation (e.g. `3a8b42..9ff173`). // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let spec = "spec_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      ignoreWhitespace: true // Boolean | Generate diffs that ignore whitespace
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugDiffstatSpecGet(
      incomingOptions.spec,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet
  /*


This endpoint is used to poll for the progress of an issue export job and return the zip file after the job is complete. As long as the job is running, this will return a 200 response with in the response body a description of the current status.  After the job has been scheduled, but before it starts executing, this endpoint&#39;s response is:  {  \&quot;type\&quot;: \&quot;issue_job_status\&quot;,  \&quot;status\&quot;: \&quot;ACCEPTED\&quot;,  \&quot;phase\&quot;: \&quot;Initializing\&quot;,  \&quot;total\&quot;: 0,  \&quot;count\&quot;: 0,  \&quot;pct\&quot;: 0 }   Then once it starts running, it becomes:  {  \&quot;type\&quot;: \&quot;issue_job_status\&quot;,  \&quot;status\&quot;: \&quot;STARTED\&quot;,  \&quot;phase\&quot;: \&quot;Attachments\&quot;,  \&quot;total\&quot;: 15,  \&quot;count\&quot;: 11,  \&quot;pct\&quot;: 73 }  Once the job has successfully completed, it returns a stream of the zip file.

 */
  repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The name of the rep // String | The ID of the export task
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let repoName = "repoName_example";*/ /*let taskId = "taskId_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.repoName,
      incomingOptions.taskId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesImportGet
  /*


When using GET, this endpoint reports the status of the current import task. Request example:  &#x60;&#x60;&#x60; $ curl -u &lt;username&gt; -X GET https://api.bitbucket.org/2.0/repositories/&lt;owner_username&gt;/&lt;repo_slug&gt;/issues/import &#x60;&#x60;&#x60;  After the job has been scheduled, but before it starts executing, this endpoint&#39;s response is:  &#x60;&#x60;&#x60; &lt; HTTP/1.1 202 Accepted {     \&quot;type\&quot;: \&quot;issue_job_status\&quot;,     \&quot;status\&quot;: \&quot;PENDING\&quot;,     \&quot;phase\&quot;: \&quot;Attachments\&quot;,     \&quot;total\&quot;: 15,     \&quot;count\&quot;: 0,     \&quot;percent\&quot;: 0 } &#x60;&#x60;&#x60;  Once it starts running, it is a 202 response with status STARTED and progress filled.  After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.

 */
  repositoriesWorkspaceRepoSlugIssuesImportGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesImportGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidLogsLogUuidGet
  /*


 */
  repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidLogsLogUuidGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DefaultApi();
    apiInstance.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidLogsLogUuidGet(
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsGet
  /*


 */
  repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DefaultApi();
    apiInstance.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsGet(
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesGet
  /*


 */
  repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DefaultApi();
    apiInstance.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesGet(
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesTestCaseUuidTestCaseReasonsGet
  /*


 */
  repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesTestCaseUuidTestCaseReasonsGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DefaultApi();
    apiInstance.repositoriesWorkspaceRepoSlugPipelinesPipelineUuidStepsStepUuidTestReportsTestCasesTestCaseUuidTestCaseReasonsGet(
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for teamsUsernamePermissionsGet
  /*


Returns an object for each team permission a user on the team has.  Permissions returned are effective permissions  if a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * &#x60;admin&#x60; * &#x60;collaborator&#x60;  Only users with admin permission for the team may access this resource.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;type\&quot;: \&quot;team_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;team\&quot;: {         \&quot;display_name\&quot;: \&quot;Atlassian Bitbucket\&quot;,         \&quot;uuid\&quot;: \&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;       }     },     {       \&quot;permission\&quot;: \&quot;collaborator\&quot;,       \&quot;type\&quot;: \&quot;team_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;seanaty\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;       },       \&quot;team\&quot;: {         \&quot;display_name\&quot;: \&quot;Atlassian Bitbucket\&quot;,         \&quot;uuid\&quot;: \&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../meta/filtering) by team, user, or permission by adding the following query string parameters:  * &#x60;q&#x3D;user.uuid&#x3D;\&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;&#x60; or &#x60;q&#x3D;permission&#x3D;\&quot;admin\&quot;&#x60; * &#x60;sort&#x3D;team.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.

 */
  teamsUsernamePermissionsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.teamsUsernamePermissionsGet(
      incomingOptions.username,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernamePermissionsRepositoriesGet
  /*


Returns an object for each repository permission for all of a teams repositories.  If the username URL parameter refers to a user account instead of a team account, an object containing the repository permissions of all the username&#39;s repositories will be returned.  Permissions returned are effective permissions  the highest level of permission the user has. This does not include public repositories that users are not granted any specific permission in, and does not distinguish between direct and indirect privileges.  Only users with admin permission for the team may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions/repositories  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     },     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../../meta/filtering) by repository, user, or permission by adding the following query string parameters:  * &#x60;q&#x3D;repository.name&#x3D;\&quot;geordi\&quot;&#x60; or &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;user.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.

 */
  teamsUsernamePermissionsRepositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.teamsUsernamePermissionsRepositoriesGet(
      incomingOptions.username,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernamePermissionsRepositoriesRepoSlugGet
  /*


Returns an object for each repository permission of a given repository.  If the username URL parameter refers to a user account instead of a team account, an object containing the repository permissions of the username&#39;s repository will be returned.  Permissions returned are effective permissions  the highest level of permission the user has. This does not include public repositories that users are not granted any specific permission in, and does not distinguish between direct and indirect privileges.  Only users with admin permission for the repository may access this resource.  Permissions can be:  * &#x60;admin&#x60; * &#x60;write&#x60; * &#x60;read&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/teams/atlassian_tutorial/permissions/repositories/geordi  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;admin\&quot;     },     {       \&quot;type\&quot;: \&quot;repository_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Conaty\&quot;,         \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;       },       \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;       },       \&quot;permission\&quot;: \&quot;write\&quot;     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../../meta/filtering) by user, or permission by adding the following query string parameters:  * &#x60;q&#x3D;permission&gt;\&quot;read\&quot;&#x60; * &#x60;sort&#x3D;user.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.

 */
  teamsUsernamePermissionsRepositoriesRepoSlugGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.teamsUsernamePermissionsRepositoriesRepoSlugGet(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for userPermissionsTeamsGet
  /*


Returns an object for each team the caller is a member of, and their effective role  the highest level of privilege the caller has. If a user is a member of multiple groups with distinct roles, only the highest level is returned.  Permissions can be:  * &#x60;admin&#x60; * &#x60;collaborator&#x60;  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/user/permissions/teams  {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;permission\&quot;: \&quot;admin\&quot;,       \&quot;type\&quot;: \&quot;team_permission\&quot;,       \&quot;user\&quot;: {         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;       },       \&quot;team\&quot;: {         \&quot;display_name\&quot;: \&quot;Atlassian Bitbucket\&quot;,         \&quot;uuid\&quot;: \&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 1 } &#x60;&#x60;&#x60;  Results may be further [filtered or sorted](../../../meta/filtering) by team or permission by adding the following query string parameters:  * &#x60;q&#x3D;team.uuid&#x3D;\&quot;{4cc6108a-a241-4db0-96a5-64347ac04f87}\&quot;&#x60; or &#x60;q&#x3D;permission&#x3D;\&quot;admin\&quot;&#x60; * &#x60;sort&#x3D;team.display_name&#x60;  Note that the query parameter values need to be URL escaped so that &#x60;&#x3D;&#x60; would become &#x60;%3D&#x60;.

 */
  userPermissionsTeamsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi();
    let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../meta/filtering).
      //  'sort': "sort_example" // String |  Name of a response property sort the result by as per [filtering and sorting](../../../meta/filtering#query-sort).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.userPermissionsTeamsGet(
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonLinkersGet
  /*


 */
  addonLinkersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi();
    apiInstance.addonLinkersGet((error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for addonLinkersLinkerKeyGet
  /*


 */
  addonLinkersLinkerKeyGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyGet(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonLinkersLinkerKeyValuesGet
  /*


 */
  addonLinkersLinkerKeyValuesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyValuesGet(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonLinkersLinkerKeyValuesGet_0
  /*


 */
  addonLinkersLinkerKeyValuesGet_0(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyValuesGet_0(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getDeploymentVariables
  /*


Find deployment environment level variables.

 */
  getDeploymentVariables(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The environment.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ apiInstance.getDeploymentVariables(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineForRepository
  /*


Retrieve a specified pipeline

 */
  getPipelineForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The pipeline UUID.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pipelineUuid = "pipelineUuid_example";*/ apiInstance.getPipelineForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pipelineUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineStepForRepository
  /*


Retrieve a given step of a pipeline.

 */
  getPipelineStepForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the pipeline // String | The UUID of the step.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pipelineUuid = "pipelineUuid_example";*/ /*let stepUuid = "stepUuid_example";*/ apiInstance.getPipelineStepForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pipelineUuid,
      incomingOptions.stepUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineStepLogForRepository
  /*


Retrieve the log file for a given step of a pipeline.  This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.

 */
  getPipelineStepLogForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the pipeline // String | The UUID of the step.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pipelineUuid = "pipelineUuid_example";*/ /*let stepUuid = "stepUuid_example";*/ apiInstance.getPipelineStepLogForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pipelineUuid,
      incomingOptions.stepUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for getPipelineStepsForRepository
  /*


Find steps for the given pipeline.

 */
  getPipelineStepsForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the pipeline.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pipelineUuid = "pipelineUuid_example";*/ apiInstance.getPipelineStepsForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pipelineUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineVariableForTeam
  /*


Retrieve a team level variable.

 */
  getPipelineVariableForTeam(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The UUID of the variable to retrieve.
    /*let username = "username_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.getPipelineVariableForTeam(
      incomingOptions.username,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineVariableForUser
  /*


Retrieve a user level variable.

 */
  getPipelineVariableForUser(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The UUID of the variable to retrieve.
    /*let username = "username_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.getPipelineVariableForUser(
      incomingOptions.username,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineVariablesForTeam
  /*


Find account level variables.

 */
  getPipelineVariablesForTeam(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account.
    /*let username = "username_example";*/ apiInstance.getPipelineVariablesForTeam(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelineVariablesForUser
  /*


Find user level variables.

 */
  getPipelineVariablesForUser(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account.
    /*let username = "username_example";*/ apiInstance.getPipelineVariablesForUser(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPipelinesForRepository
  /*


Find pipelines

 */
  getPipelinesForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getPipelinesForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineConfig
  /*


Retrieve the repository pipelines configuration.

 */
  getRepositoryPipelineConfig(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getRepositoryPipelineConfig(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineKnownHost
  /*


Retrieve a repository level known host.

 */
  getRepositoryPipelineKnownHost(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the known host to retrieve.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let knownHostUuid = "knownHostUuid_example";*/ apiInstance.getRepositoryPipelineKnownHost(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.knownHostUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineKnownHosts
  /*


Find repository level known hosts.

 */
  getRepositoryPipelineKnownHosts(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getRepositoryPipelineKnownHosts(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineSchedule
  /*


Retrieve a schedule by its UUID.

 */
  getRepositoryPipelineSchedule(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The uuid of the schedule.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let scheduleUuid = "scheduleUuid_example";*/ apiInstance.getRepositoryPipelineSchedule(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.scheduleUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineScheduleExecutions
  /*


Retrieve the executions of a given schedule.

 */
  getRepositoryPipelineScheduleExecutions(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getRepositoryPipelineScheduleExecutions(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineSchedules
  /*


Retrieve the configured schedules for the given repository.

 */
  getRepositoryPipelineSchedules(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getRepositoryPipelineSchedules(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineSshKeyPair
  /*


Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.

 */
  getRepositoryPipelineSshKeyPair(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getRepositoryPipelineSshKeyPair(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineVariable
  /*


Retrieve a repository level variable.

 */
  getRepositoryPipelineVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the variable to retrieve.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.getRepositoryPipelineVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getRepositoryPipelineVariables
  /*


Find repository level variables.

 */
  getRepositoryPipelineVariables(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getRepositoryPipelineVariables(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugComponentsComponentIdGet
  /*


Returns the specified issue tracker component object.

 */
  repositoriesWorkspaceRepoSlugComponentsComponentIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // Number | The component's i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let componentId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugComponentsComponentIdGet(
      incomingOptions.componentId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugComponentsGet
  /*


Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.

 */
  repositoriesWorkspaceRepoSlugComponentsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugComponentsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesGet
  /*


Returns the issues in the issue tracker.

 */
  repositoriesWorkspaceRepoSlugIssuesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet
  /*


Returns all attachments for this issue.  This returns the files&#39; meta data. This does not return the files&#39; actual contents.  The files are always ordered by their upload date.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Number | The issue's id
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let issueId = 56;*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.issueId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet
  /*


Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let path = "path_example";*/ /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathGet(
      incomingOptions.path,
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet
  /*


Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue change i // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let changeId = "changeId_example";*/ /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdGet(
      incomingOptions.changeId,
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet
  /*


Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the &#x60;/issues/123/changes&#x60; endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .  {   \&quot;pagelen\&quot;: 20,   \&quot;values\&quot;: [     {       \&quot;changes\&quot;: {         \&quot;priority\&quot;: {           \&quot;new\&quot;: \&quot;trivial\&quot;,           \&quot;old\&quot;: \&quot;major\&quot;         },         \&quot;assignee\&quot;: {           \&quot;new\&quot;: \&quot;\&quot;,           \&quot;old\&quot;: \&quot;evzijst\&quot;         },         \&quot;assignee_account_id\&quot;: {           \&quot;new\&quot;: \&quot;\&quot;,           \&quot;old\&quot;: \&quot;557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\&quot;         },         \&quot;kind\&quot;: {           \&quot;new\&quot;: \&quot;enhancement\&quot;,           \&quot;old\&quot;: \&quot;bug\&quot;         }       },       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/dogslow/issues/1#comment-2\&quot;         }       },       \&quot;issue\&quot;: {         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1\&quot;           }         },         \&quot;type\&quot;: \&quot;issue\&quot;,         \&quot;id\&quot;: 1,         \&quot;repository\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/evzijst/dogslow\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/dogslow\&quot;             },             \&quot;avatar\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/dogslow/avatar/32/\&quot;             }           },           \&quot;type\&quot;: \&quot;repository\&quot;,           \&quot;name\&quot;: \&quot;dogslow\&quot;,           \&quot;full_name\&quot;: \&quot;evzijst/dogslow\&quot;,           \&quot;uuid\&quot;: \&quot;{988b17c6-1a47-4e70-84ee-854d5f012bf6}\&quot;         },         \&quot;title\&quot;: \&quot;Updated title\&quot;       },       \&quot;created_on\&quot;: \&quot;2018-03-03T00:35:28.353630+00:00\&quot;,       \&quot;user\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;evzijst\&quot;,         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;uuid\&quot;: \&quot;{aaa7972b-38af-4fb1-802d-6e3854c95778}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst/\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/account/evzijst/avatar/32/\&quot;           }         }       },       \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Removed assignee, changed kind and priority.\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Removed assignee, changed kind and priority.&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;       },       \&quot;type\&quot;: \&quot;issue_change\&quot;,       \&quot;id\&quot;: 2     }   ],   \&quot;page\&quot;: 1 } &#x60;&#x60;&#x60;  Changes support [filtering and sorting](../../../meta/filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \&quot;resolved\&quot;:  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode&#x3D;&#39;q&#x3D;changes.state.new &#x3D; \&quot;resolved\&quot;&#39; &#x60;&#x60;&#x60;  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The &#x60;changes.assignee&#x60; and &#x60;changes.assignee_account_id&#x60; fields are not a &#x60;user&#x60; object. Instead, they contain the raw &#x60;username&#x60; and &#x60;account_id&#x60; of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The &#x60;changes.assignee&#x60; field is deprecated will disappear in the future. Use &#x60;changes.assignee_account_id&#x60; instead.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response. See [filtering and sorting](../../../meta/filtering) for details.
      //  'sort': "sort_example" // String |  Name of a response property to sort results. See [filtering and sorting](../../../meta/filtering#query-sort) for details.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesGet(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet
  /*


Returns the specified issue comment object.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The ID of the issue that is being queried.
    /*let commentId = "commentId_example";*/ /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let issueId = "issueId_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdGet(
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.issueId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet
  /*


Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'q': "q_example" // String |  Query string to narrow down the response as per [filtering and sorting](../../../../../../meta/filtering).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsGet(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdGet
  /*


Returns the specified issue.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdGet(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet
  /*


Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven&#39;t.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteGet(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet
  /*


Indicated whether or not the authenticated user is watching this issue.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchGet(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugMilestonesGet
  /*


Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.

 */
  repositoriesWorkspaceRepoSlugMilestonesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugMilestonesGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet
  /*


Returns the specified issue tracker milestone object.

 */
  repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // Number | The milestone's i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let milestoneId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugMilestonesMilestoneIdGet(
      incomingOptions.milestoneId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugVersionsGet
  /*


Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.

 */
  repositoriesWorkspaceRepoSlugVersionsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugVersionsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugVersionsVersionIdGet
  /*


Returns the specified issue tracker version object.

 */
  repositoriesWorkspaceRepoSlugVersionsVersionIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // Number | The version's i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let versionId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugVersionsVersionIdGet(
      incomingOptions.versionId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchRestrictionsGet
  /*


Returns a paginated list of all branch restrictions on the repository.

 */
  repositoriesWorkspaceRepoSlugBranchRestrictionsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchrestrictionsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'kind': "kind_example", // String | Branch restrictions of this type
      //  'pattern': "pattern_example" // String | Branch restrictions applied to branches of this pattern
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugBranchRestrictionsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet
  /*


Returns a specific branch restriction rule.

 */
  repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchrestrictionsApi(); // String | The restriction rule's i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let id = "id_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugBranchRestrictionsIdGet(
      incomingOptions.id,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsGet
  /*


Returns all the teams that the authenticated user is associated with.

 */
  teamsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi();
    let opts = {
      //  'role': "role_example" // String |  Filters the teams based on the authenticated user's role on each team.  * **member**: returns a list of all the teams which the caller is a member of   at least one team group or repository owned by the team * **contributor**: returns a list of teams which the caller has write access   to at least one repository owned by the team * **admin**: returns a list teams which the caller has team administrator access
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.teamsGet(incomingOptions.opts, (error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for teamsUsernameFollowersGet
  /*


Returns the list of accounts that are following this team.

 */
  teamsUsernameFollowersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | The team's username
    /*let username = "username_example";*/ apiInstance.teamsUsernameFollowersGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameFollowingGet
  /*


Returns the list of accounts this team is following.

 */
  teamsUsernameFollowingGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | The team's username
    /*let username = "username_example";*/ apiInstance.teamsUsernameFollowingGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameGet
  /*


Gets the public information associated with a team.  If the team&#39;s profile is private, &#x60;location&#x60;, &#x60;website&#x60; and &#x60;created_on&#x60; elements are omitted.

 */
  teamsUsernameGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | The team's username or UUID.
    /*let username = "username_example";*/ apiInstance.teamsUsernameGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksGet
  /*


Returns a paginated list of webhooks installed on this team.

 */
  teamsUsernameHooksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameHooksGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksUidGet
  /*


Returns the webhook with the specified id installed on the given team account.

 */
  teamsUsernameHooksUidGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id.
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.teamsUsernameHooksUidGet(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameMembersGet
  /*


Returns all members of the specified team. Any member of any of the team&#39;s groups is considered a member of the team. This includes users in groups that may not actually have access to any of the team&#39;s repositories.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.

 */
  teamsUsernameMembersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameMembersGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameRepositoriesGet
  /*


All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.

 */
  teamsUsernameRepositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameRepositoriesGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameMembersGet
  /*


Returns all members of the specified team. Any member of any of the team&#39;s groups is considered a member of the team. This includes users in groups that may not actually have access to any of the team&#39;s repositories.  This operation has been deprecated due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/) for details.

 */
  usersUsernameMembersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameMembersGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameRepositoriesGet
  /*


All repositories owned by a user/team. This includes private repositories, but filtered down to the ones that the calling user has access to.

 */
  usersUsernameRepositoriesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameRepositoriesGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsGet
  /*


Returns all snippets. Like pull requests, repositories and teams, the full set of snippets is defined by what the current user has access to.  This includes all snippets owned by the current user, but also all snippets owned by any of the teams the user is a member of, or snippets by other users that the current user is either watching or has collaborated on (for instance by commenting on it).  To limit the set of returned snippets, apply the &#x60;?role&#x3D;[owner|contributor|member]&#x60; query parameter where the roles are defined as follows:  * &#x60;owner&#x60;: all snippets owned by the current user * &#x60;contributor&#x60;: all snippets owned by, or watched by the current user * &#x60;member&#x60;: owned by the user, their teams, or watched by the current user  When no role is specified, all public snippets are returned, as well as all privately owned snippets watched or commented on.  The returned response is a normal paginated JSON list. This endpoint only supports &#x60;application/json&#x60; responses and no &#x60;multipart/form-data&#x60; or &#x60;multipart/related&#x60;. As a result, it is not possible to include the file contents.

 */
  snippetsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi();
    let opts = {
      //  'role': "role_example" // String | Filter down the result based on the authenticated user's role (`owner`, `contributor`, or `member`).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.snippetsGet(incomingOptions.opts, (error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for snippetsWorkspaceEncodedIdCommentsCommentIdGet
  /*


Returns the specific snippet comment.

 */
  snippetsWorkspaceEncodedIdCommentsCommentIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let commentId = "commentId_example";*/ /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdCommentsCommentIdGet(
      incomingOptions.commentId,
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdCommentsGet
  /*


Used to retrieve a paginated list of all comments for a specific snippet.  This resource works identical to commit and pull request comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.

 */
  snippetsWorkspaceEncodedIdCommentsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdCommentsGet(
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdCommitsGet
  /*


Returns the changes (commits) made on this snippet.

 */
  snippetsWorkspaceEncodedIdCommitsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdCommitsGet(
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdCommitsRevisionGet
  /*


 */
  snippetsWorkspaceEncodedIdCommitsRevisionGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String |
    /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ /*let revision = "revision_example";*/ apiInstance.snippetsWorkspaceEncodedIdCommitsRevisionGet(
      incomingOptions.encodedId,
      incomingOptions.workspace,
      incomingOptions.revision,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdGet
  /*


Retrieves a single snippet.  Snippets support multiple content types:  * application/json * multipart/related * multipart/form-data   application/json ----------------  The default content type of the response is &#x60;application/json&#x60;. Since JSON is always &#x60;utf-8&#x60;, it cannot reliably contain file contents for files that are not text. Therefore, JSON snippet documents only contain the filename and links to the file contents.  This means that in order to retrieve all parts of a snippet, N+1 requests need to be made (where N is the number of files in the snippet).   multipart/related -----------------  To retrieve an entire snippet in a single response, use the &#x60;Accept: multipart/related&#x60; HTTP request header.      $ curl -H \&quot;Accept: multipart/related\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/1  Response:      HTTP/1.1 200 OK     Content-Length: 2214     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj\&quot;         },         \&quot;comments\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/comments\&quot;         },         \&quot;watchers\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/watchers\&quot;         },         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/commits\&quot;         }       },       \&quot;id\&quot;: kypj,       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;created_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;updated_on\&quot;: \&quot;2014-12-29T22:22:04.790331+00:00\&quot;,       \&quot;is_private\&quot;: false,       \&quot;files\&quot;: {         \&quot;foo.txt\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/foo.txt\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-foo.txt\&quot;             }           }         },         \&quot;image.png\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/snippets/evzijst/kypj/files/367ab19/image.png\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/snippets/evzijst/kypj#file-image.png\&quot;             }           }         }       ],       \&quot;owner\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       },       \&quot;creator\&quot;: {         \&quot;username\&quot;: \&quot;evzijst\&quot;,         \&quot;nickname\&quot;: \&quot;evzijst\&quot;,         \&quot;display_name\&quot;: \&quot;Erik van Zijst\&quot;,         \&quot;uuid\&quot;: \&quot;{d301aafa-d676-4ee0-88be-962be7417567}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/evzijst\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/evzijst\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket-staging-assetroot.s3.amazonaws.com/c/photos/2013/Jul/31/erik-avatar-725122544-0_avatar.png\&quot;           }         }       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  multipart/form-data -------------------  As with creating new snippets, &#x60;multipart/form-data&#x60; can be used as an alternative to &#x60;multipart/related&#x60;. However, the inherently flat structure of form-data means that only basic, root-level properties can be returned, while nested elements like &#x60;links&#x60; are omitted:      $ curl -H \&quot;Accept: multipart/form-data\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj  Response:      HTTP/1.1 200 OK     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;     Content-Type: text/plain; charset&#x3D;\&quot;utf-8\&quot;      My snippet     ------------------------------63a4b224c59f--     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: attachment; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Transfer-Encoding: base64     Content-Type: application/octet-stream      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     ------------------------------5957323a6b76--

 */
  snippetsWorkspaceEncodedIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet's id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdGet(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdNodeIdFilesPathGet
  /*


Retrieves the raw contents of a specific file in the snippet. The &#x60;Content-Disposition&#x60; header will be \&quot;attachment\&quot; to avoid issues with malevolent executable files.  The file&#39;s mime type is derived from its filename and returned in the &#x60;Content-Type&#x60; header.  Note that for text files, no character encoding is included as part of the content type.

 */
  snippetsWorkspaceEncodedIdNodeIdFilesPathGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let path = "path_example";*/ /*let nodeId = "nodeId_example";*/ /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdNodeIdFilesPathGet(
      incomingOptions.path,
      incomingOptions.nodeId,
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdNodeIdGet
  /*


Identical to &#x60;GET /snippets/encoded_id&#x60;, except that this endpoint can be used to retrieve the contents of the snippet as it was at an older revision, while &#x60;/snippets/encoded_id&#x60; always returns the snippet&#39;s current revision.  Note that only the snippet&#39;s file contents are versioned, not its meta data properties like the title.  Other than that, the two endpoints are identical in behavior.

 */
  snippetsWorkspaceEncodedIdNodeIdGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet's id // String | A commit revision (SHA1).
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ /*let nodeId = "nodeId_example";*/ apiInstance.snippetsWorkspaceEncodedIdNodeIdGet(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      incomingOptions.nodeId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdRevisionDiffGet
  /*


Returns the diff of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;patch&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the diff is unspecified as Git and Mercurial do not track this, making it hard for Bitbucket to reliably determine this.

 */
  snippetsWorkspaceEncodedIdRevisionDiffGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet id // String | A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ /*let revision = "revision_example";*/ let opts = {
      //  'path': "path_example" // String | When used, only one the diff of the specified file will be returned.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.snippetsWorkspaceEncodedIdRevisionDiffGet(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      incomingOptions.revision,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdRevisionPatchGet
  /*


Returns the patch of the specified commit against its first parent.  Note that this resource is different in functionality from the &#x60;diff&#x60; resource.  The differences between a diff and a patch are:  * patches have a commit header with the username, message, etc * diffs support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter the   diff to just that one file diff (not supported for patches) * for a merge, the diff will show the diff between the merge commit and   its first parent (identical to how PRs work), while patch returns a   response containing separate patches for each commit on the second   parent&#39;s ancestry, up to the oldest common ancestor (identical to   its reachability).  Note that the character encoding of the contents of the patch is unspecified as Git and Mercurial do not track this, making it hard for Bitbucket to reliably determine this.

 */
  snippetsWorkspaceEncodedIdRevisionPatchGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet id // String | A revspec expression. This can simply be a commit SHA1, a ref name, or a compare expression like `staging..production`.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ /*let revision = "revision_example";*/ apiInstance.snippetsWorkspaceEncodedIdRevisionPatchGet(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      incomingOptions.revision,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdWatchGet
  /*


Used to check if the current user is watching a specific snippet.  Returns 204 (No Content) if the user is watching the snippet and 404 if not.  Hitting this endpoint anonymously always returns a 404.

 */
  snippetsWorkspaceEncodedIdWatchGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdWatchGet(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdWatchersGet
  /*


Returns a paginated list of all users watching a specific snippet.

 */
  snippetsWorkspaceEncodedIdWatchersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdWatchersGet(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceGet
  /*


Identical to &#x60;/snippets&#x60;, except that the result is further filtered by the snippet owner and only those that are owned by &#x60;{workspace}&#x60; are returned.

 */
  snippetsWorkspaceGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | Limits the result to snippets owned by this user.
    /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ let opts = {
      //  'role': "role_example" // String | Filter down the result based on the authenticated user's role (`owner`, `contributor`, or `member`).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.snippetsWorkspaceGet(
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getPullrequestsForCommit
  /*
Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when &#39;Go to pull request&#39; is clicked from the web interface for a commit&#39;s details.

 */
  getPullrequestsForCommit(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | The account; either the UUID in curly braces, or the account_i // String | The repository; either the UUID in curly braces, or the slu // String | The SHA1 of the commit
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let commit = "commit_example";*/ let opts = {
      page: 1, // Number | Which page to retrieve
      pagelen: 30 // Number | How many pull requests to retrieve per page
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.getPullrequestsForCommit(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.commit,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for pullrequestsSelectedUserGet
  /*


Returns all pull requests authored by the specified user.  By default only open pull requests are returned. This can be controlled using the &#x60;state&#x60; query parameter. To retrieve pull requests that are in one of multiple states, repeat the &#x60;state&#x60; parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.

 */
  pullrequestsSelectedUserGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the username of the pull request author, the author's UUID surrounded by curly-braces, for example: `{account UUID}`, or the author's Atlassian ID.
    /*let selectedUser = "selectedUser_example";*/ let opts = {
      //  'state': "state_example" // String | Only return pull requests that are in this state. This parameter can be repeated.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.pullrequestsSelectedUserGet(
      incomingOptions.selectedUser,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDefaultReviewersGet
  /*


Returns the repository&#39;s default reviewers.  These are the users that are automatically added as reviewers on every new pull request that is created.

 */
  repositoriesWorkspaceRepoSlugDefaultReviewersGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDefaultReviewersGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet
  /*


Returns the specified reviewer.  This can be used to test whether a user is among the repository&#39;s default reviewers list. A 404 indicates that that specified user is not a default reviewer.

 */
  repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let targetUsername = "targetUsername_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameGet(
      incomingOptions.targetUsername,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsActivityGet
  /*


Returns a paginated list of the pull request&#39;s activity log.  This includes comments that were made by the reviewers, updates and approvals.  Comments created on a file or a line of code have an inline property.  Comment example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;comment\&quot;: {                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\&quot;                     }                 },                 \&quot;deleted\&quot;: false,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;content\&quot;: {                     \&quot;raw\&quot;: \&quot;inline with to a dn from lines\&quot;,                     \&quot;markup\&quot;: \&quot;markdown\&quot;,                     \&quot;html\&quot;: \&quot;&lt;p&gt;inline with to a dn from lines&lt;/p&gt;\&quot;,                     \&quot;type\&quot;: \&quot;rendered\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;updated_on\&quot;: \&quot;2019-09-27T00:33:46.055384+00:00\&quot;,                 \&quot;inline\&quot;: {                     \&quot;context_lines\&quot;: \&quot;\&quot;,                     \&quot;to\&quot;: null,                     \&quot;path\&quot;: \&quot;\&quot;,                     \&quot;outdated\&quot;: false,                     \&quot;from\&quot;: 211                 },                 \&quot;type\&quot;: \&quot;pullrequest_comment\&quot;,                 \&quot;id\&quot;: 118571088             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;update\&quot;: {                 \&quot;description\&quot;: \&quot;\&quot;,                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;,                 \&quot;destination\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;6a2c16e4a152\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;master\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;reason\&quot;: \&quot;\&quot;,                 \&quot;source\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;728c8bad1813\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;username/NONE-add-onClick-prop-for-accessibility\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;state\&quot;: \&quot;OPEN\&quot;,                 \&quot;author\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;date\&quot;: \&quot;2019-05-10T06:48:25.305565+00:00\&quot;             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Approval example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;approval\&quot;: {                 \&quot;date\&quot;: \&quot;2019-09-27T00:37:19.849534+00:00\&quot;,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 }             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugPullrequestsActivityGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // Number | The id of the pull request // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsActivityGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsGet
  /*


Returns all pull requests on the specified repository.  By default only open pull requests are returned. This can be controlled using the &#x60;state&#x60; query parameter. To retrieve pull requests that are in one of multiple states, repeat the &#x60;state&#x60; parameter for each individual state.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../meta/filtering) for more details.

 */
  repositoriesWorkspaceRepoSlugPullrequestsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'state': "state_example" // String | Only return pull requests that are in this state. This parameter can be repeated.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugPullrequestsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet
  /*


Returns a paginated list of the pull request&#39;s activity log.  This includes comments that were made by the reviewers, updates and approvals.  Comments created on a file or a line of code have an inline property.  Comment example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;comment\&quot;: {                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088\&quot;                     }                 },                 \&quot;deleted\&quot;: false,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;content\&quot;: {                     \&quot;raw\&quot;: \&quot;inline with to a dn from lines\&quot;,                     \&quot;markup\&quot;: \&quot;markdown\&quot;,                     \&quot;html\&quot;: \&quot;&lt;p&gt;inline with to a dn from lines&lt;/p&gt;\&quot;,                     \&quot;type\&quot;: \&quot;rendered\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;created_on\&quot;: \&quot;2019-09-27T00:33:46.039178+00:00\&quot;,                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;updated_on\&quot;: \&quot;2019-09-27T00:33:46.055384+00:00\&quot;,                 \&quot;inline\&quot;: {                     \&quot;context_lines\&quot;: \&quot;\&quot;,                     \&quot;to\&quot;: null,                     \&quot;path\&quot;: \&quot;\&quot;,                     \&quot;outdated\&quot;: false,                     \&quot;from\&quot;: 211                 },                 \&quot;type\&quot;: \&quot;pullrequest_comment\&quot;,                 \&quot;id\&quot;: 118571088             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Updates include a state property of OPEN, MERGED, or DECLINED.  Update example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;update\&quot;: {                 \&quot;description\&quot;: \&quot;\&quot;,                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;,                 \&quot;destination\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;6a2c16e4a152\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;master\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;reason\&quot;: \&quot;\&quot;,                 \&quot;source\&quot;: {                     \&quot;commit\&quot;: {                         \&quot;type\&quot;: \&quot;commit\&quot;,                         \&quot;hash\&quot;: \&quot;728c8bad1813\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813\&quot;                             }                         }                     },                     \&quot;branch\&quot;: {                         \&quot;name\&quot;: \&quot;username/NONE-add-onClick-prop-for-accessibility\&quot;                     },                     \&quot;repository\&quot;: {                         \&quot;name\&quot;: \&quot;Atlaskit-MK-2\&quot;,                         \&quot;type\&quot;: \&quot;repository\&quot;,                         \&quot;full_name\&quot;: \&quot;atlassian/atlaskit-mk-2\&quot;,                         \&quot;links\&quot;: {                             \&quot;self\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;html\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2\&quot;                             },                             \&quot;avatar\&quot;: {                                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B%7D?ts&#x3D;js\&quot;                             }                         },                         \&quot;uuid\&quot;: \&quot;{}\&quot;                     }                 },                 \&quot;state\&quot;: \&quot;OPEN\&quot;,                 \&quot;author\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 },                 \&quot;date\&quot;: \&quot;2019-05-10T06:48:25.305565+00:00\&quot;             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;  Approval example: &#x60;&#x60;&#x60; {     \&quot;pagelen\&quot;: 20,     \&quot;values\&quot;: [         {             \&quot;approval\&quot;: {                 \&quot;date\&quot;: \&quot;2019-09-27T00:37:19.849534+00:00\&quot;,                 \&quot;pullrequest\&quot;: {                     \&quot;type\&quot;: \&quot;pullrequest\&quot;,                     \&quot;id\&quot;: 5695,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                         }                     },                     \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;                 },                 \&quot;user\&quot;: {                     \&quot;display_name\&quot;: \&quot;Name Lastname\&quot;,                     \&quot;uuid\&quot;: \&quot;{}\&quot;,                     \&quot;links\&quot;: {                         \&quot;self\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/users/%7B%7D\&quot;                         },                         \&quot;html\&quot;: {                             \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B%7D/\&quot;                         },                         \&quot;avatar\&quot;: {                             \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128\&quot;                         }                     },                     \&quot;type\&quot;: \&quot;user\&quot;,                     \&quot;nickname\&quot;: \&quot;Name\&quot;,                     \&quot;account_id\&quot;: \&quot;\&quot;                 }             },             \&quot;pull_request\&quot;: {                 \&quot;type\&quot;: \&quot;pullrequest\&quot;,                 \&quot;id\&quot;: 5695,                 \&quot;links\&quot;: {                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/!api/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695\&quot;                     }                 },                 \&quot;title\&quot;: \&quot;username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it\&quot;             }         }     ] } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // Number | The id of the pull request // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet
  /*


Returns a specific pull request comment.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let commentId = "commentId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdGet(
      incomingOptions.pullRequestId,
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet
  /*


Returns a paginated list of the pull request&#39;s comments.  This includes both global, inline comments and replies.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Number | The id of the pull request.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullRequestId = 56;*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.pullRequestId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet
  /*


Returns a paginated list of the pull request&#39;s commits.  These are the commits that are being merged into the destination branch when the pull requests gets accepted.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet
  /*


Redirects to the [repository diff](../../diff/%7Bspec%7D) with the revspec that corresponds to the pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet
  /*


Redirects to the [repository diffstat](../../diffstat/%7Bspec%7D) with the revspec that corresponds to the pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet
  /*


Returns the specified pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Number | The id of the pull request.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullRequestId = 56;*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.pullRequestId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet
  /*


 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet
  /*


Returns all statuses (e.g. build results) for the given pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // Number | The id of the pull request // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesGet(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for searchAccount
  /*
Search for code in the repositories of the specified team

 */
  searchAccount(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.SearchApi(); // String | The account to search in; either the username or the UUID in curly brace // String | The search query
    /*let username = "username_example";*/ /*let searchQuery = "searchQuery_example";*/ let opts = {
      page: 1, // Number | Which page of the search results to retrieve
      pagelen: 10 // Number | How many search results to retrieve per page
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.searchAccount(
      incomingOptions.username,
      incomingOptions.searchQuery,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for searchAccount_0
  /*
Search for code in the repositories of the specified user

 */
  searchAccount_0(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.SearchApi(); // String | The account to search in; either the username or the UUID in curly brace // String | The search query
    /*let username = "username_example";*/ /*let searchQuery = "searchQuery_example";*/ let opts = {
      page: 1, // Number | Which page of the search results to retrieve
      pagelen: 10 // Number | How many search results to retrieve per page
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.searchAccount_0(
      incomingOptions.username,
      incomingOptions.searchQuery,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDownloadsFilenameGet
  /*


Return a redirect to the contents of a download artifact.  This endpoint returns the actual file contents and not the artifact&#39;s metadata.      $ curl -s -L https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads/hello.txt     Hello World

 */
  repositoriesWorkspaceRepoSlugDownloadsFilenameGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DownloadsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let filename = "filename_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDownloadsFilenameGet(
      incomingOptions.filename,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDownloadsGet
  /*


Returns a list of download links associated with the repository.

 */
  repositoriesWorkspaceRepoSlugDownloadsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DownloadsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDownloadsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIdGet
  /*


Returns the specified commit comment.

 */
  repositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIdGet(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | The commit's SHA1 // Number | The id of the comment // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let commentId = 56;*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeCommentsCommentIdGet(
      incomingOptions.node,
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeCommentsGet
  /*


Returns the commit&#39;s comments.  This includes both global and inline comments.  The default sorting is oldest to newest and can be overridden with the &#x60;sort&#x60; query parameter.

 */
  repositoriesWorkspaceRepoSlugCommitNodeCommentsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeCommentsGet(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeGet
  /*


Returns the specified commit.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a1 {     \&quot;rendered\&quot;: {         \&quot;message\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;         }     },     \&quot;hash\&quot;: \&quot;f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;,     \&quot;repository\&quot;: {         \&quot;name\&quot;: \&quot;geordi\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;full_name\&quot;: \&quot;bitbucket/geordi\&quot;,         \&quot;links\&quot;: {             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi\&quot;             },             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bytebucket.org/ravatar/%7B85d08b4e-571d-44e9-a507-fa476535aa98%7D?ts&#x3D;1730260\&quot;             }         },         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/comments\&quot;         },         \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/patch/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/diff/f7591a13eda445d9a9167f98eb870319f4b6c2d8\&quot;         },         \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/approve\&quot;         },         \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f7591a13eda445d9a9167f98eb870319f4b6c2d8/statuses\&quot;         }     },     \&quot;author\&quot;: {         \&quot;raw\&quot;: \&quot;Brodie Rao &lt;a@b.c&gt;\&quot;,         \&quot;type\&quot;: \&quot;author\&quot;,         \&quot;user\&quot;: {             \&quot;display_name\&quot;: \&quot;Brodie Rao\&quot;,             \&quot;uuid\&quot;: \&quot;{9484702e-c663-4afd-aefb-c93a8cd31c28}\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/%7B9484702e-c663-4afd-aefb-c93a8cd31c28%7D/\&quot;                 },                 \&quot;avatar\&quot;: {                     \&quot;href\&quot;: \&quot;https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca/613070db-28b0-421f-8dba-ae8a87e2a5c7/128\&quot;                 }             },             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;nickname\&quot;: \&quot;brodie\&quot;,             \&quot;account_id\&quot;: \&quot;557058:3aae1e05-702a-41e5-81c8-f36f29afb6ca\&quot;         }     },     \&quot;summary\&quot;: {         \&quot;raw\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,         \&quot;markup\&quot;: \&quot;markdown\&quot;,         \&quot;html\&quot;: \&quot;&lt;p&gt;Add a GEORDI_OUTPUT_DIR setting&lt;/p&gt;\&quot;,         \&quot;type\&quot;: \&quot;rendered\&quot;     },     \&quot;participants\&quot;: [],     \&quot;parents\&quot;: [         {             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;hash\&quot;: \&quot;f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/bitbucket/geordi/commit/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 },                 \&quot;html\&quot;: {                     \&quot;href\&quot;: \&quot;https://bitbucket.org/bitbucket/geordi/commits/f06941fec4ef6bcb0c2456927a0cf258fa4f899b\&quot;                 }             }         }     ],     \&quot;date\&quot;: \&quot;2012-07-16T19:37:54+00:00\&quot;,     \&quot;message\&quot;: \&quot;Add a GEORDI_OUTPUT_DIR setting\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot; } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugCommitNodeGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeGet(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitsGet
  /*


These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60; and &#x60;hg log&#x60;. Like these tools, the DAG can be filtered.  ## GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60; and &#x60;hg log&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on rev &#x60;master&#x60; (similar to &#x60;git log master&#x60;, &#x60;hg log master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/dev?exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.

 */
  repositoriesWorkspaceRepoSlugCommitsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitsGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitsRevisionGet
  /*


These are the repository&#39;s commits. They are paginated and returned in reverse chronological order, similar to the output of &#x60;git log&#x60; and &#x60;hg log&#x60;. Like these tools, the DAG can be filtered.  ## GET /repositories/{workspace}/{repo_slug}/commits/  Returns all commits in the repo in topological order (newest commit first). All branches and tags are included (similar to &#x60;git log --all&#x60; and &#x60;hg log&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/master  Returns all commits on rev &#x60;master&#x60; (similar to &#x60;git log master&#x60;, &#x60;hg log master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/dev?exclude&#x3D;master  Returns all commits on ref &#x60;dev&#x60;, except those that are reachable on &#x60;master&#x60; (similar to &#x60;git log dev ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?exclude&#x3D;master  Returns all commits in the repo that are not on master (similar to &#x60;git log --all ^master&#x60;).  ## GET /repositories/{workspace}/{repo_slug}/commits/?include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;fu&amp;exclude&#x3D;fubar  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;fu&#x60; or &#x60;fubar&#x60; (similar to &#x60;git log foo bar ^fu ^fubar&#x60;).  An optional &#x60;path&#x60; parameter can be specified that will limit the results to commits that affect that path. &#x60;path&#x60; can either be a file or a directory. If a directory is specified, commits are returned that have modified any file in the directory tree rooted by &#x60;path&#x60;. It is important to note that if the &#x60;path&#x60; parameter is specified, the commits returned by this endpoint may no longer be a DAG, parent commits that do not modify the path will be omitted from the response.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;README.md&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed the file README.md.  ## GET /repositories/{workspace}/{repo_slug}/commits/?path&#x3D;src/&amp;include&#x3D;foo&amp;include&#x3D;bar&amp;exclude&#x3D;master  Returns all commits that are on refs &#x60;foo&#x60; or &#x60;bar&#x60;, but not on &#x60;master&#x60; that changed to a file in any file in the directory src or its children.  Because the response could include a very large number of commits, it is paginated. Follow the &#39;next&#39; link in the response to navigate to the next page of commits. As with other paginated resources, do not construct your own links.  When the include and exclude parameters are more than can fit in a query string, clients can use a &#x60;x-www-form-urlencoded&#x60; POST instead.

 */
  repositoriesWorkspaceRepoSlugCommitsRevisionGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let revision = "revision_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitsRevisionGet(
      incomingOptions.revision,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDiffSpecGet
  /*


Produces a raw, git-style diff for either a single commit (diffed against its first parent), or a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a 3-way diff, or merge diff, is computed. This shows the changes introduced by the left branch (&#x60;3a8b42&#x60; in our example) as compared againt the right branch (&#x60;9ff173&#x60;).  This is equivalent to merging the left branch into the right branch and then computing the diff of the merge commit against its first parent (the right branch). This follows the same behavior as pull requests that also show this style of 3-way, or merge diff.  While similar to patches, diffs:  * Don&#39;t have a commit header (username, commit message, etc) * Support the optional &#x60;path&#x3D;foo/bar.py&#x60; query param to filter   the diff to just that one file diff  The raw diff is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.

 */
  repositoriesWorkspaceRepoSlugDiffSpecGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let spec = "spec_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      context: 56, // Number | Generate diffs with <n> lines of context instead of the usual three
      //  'path': "path_example", // String | Limit the diff to a particular file (this parameter can be repeated for multiple paths)
      ignoreWhitespace: true, // Boolean | Generate diffs that ignore whitespace
      binary: true // Boolean | Generate diffs that include binary files,true if omitted.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugDiffSpecGet(
      incomingOptions.spec,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPatchSpecGet
  /*


Produces a raw patch for a single commit (diffed against its first parent), or a patch-series for a revspec of 2 commits (e.g. &#x60;3a8b42..9ff173&#x60; where the first commit represents the source and the second commit the destination).  In case of the latter (diffing a revspec), a patch series is returned for the commits on the source branch (&#x60;3a8b42&#x60; and its ancestors in our example). For Mercurial, a single patch is returned that combines the changes of all commits on the source branch.  While similar to diffs, patches:  * Have a commit header (username, commit message, etc) * Do not support the &#x60;path&#x3D;foo/bar.py&#x60; query parameter  The raw patch is returned as-is, in whatever encoding the files in the repository use. It is not decoded into unicode. As such, the content-type is &#x60;text/plain&#x60;.

 */
  repositoriesWorkspaceRepoSlugPatchSpecGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let spec = "spec_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPatchSpecGet(
      incomingOptions.spec,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for getDeploymentForRepository
  /*


Retrieve a deployment

 */
  getDeploymentForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository // String | The deployment UUID.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let deploymentUuid = "deploymentUuid_example";*/ apiInstance.getDeploymentForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.deploymentUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getDeploymentsForRepository
  /*


Find deployments

 */
  getDeploymentsForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getDeploymentsForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getEnvironmentForRepository
  /*


Retrieve an environment

 */
  getEnvironmentForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository // String | The environment UUID.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ apiInstance.getEnvironmentForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for getEnvironmentsForRepository
  /*


Find environments

 */
  getEnvironmentsForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.getEnvironmentsForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for hookEventsGet
  /*


Returns the webhook resource or subject types on which webhooks can be registered.  Each resource/subject type contains an &#x60;events&#x60; link that returns the paginated list of specific events each individual subject type can emit.  This endpoint is publicly accessible and does not require authentication or scopes.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/hook_events  {     \&quot;repository\&quot;: {         \&quot;links\&quot;: {             \&quot;events\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/hook_events/repository\&quot;             }         }     },     \&quot;team\&quot;: {         \&quot;links\&quot;: {             \&quot;events\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/hook_events/team\&quot;             }         }     },     \&quot;user\&quot;: {         \&quot;links\&quot;: {             \&quot;events\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/hook_events/user\&quot;             }         }     } } &#x60;&#x60;&#x60;

 */
  hookEventsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi();
    apiInstance.hookEventsGet((error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for hookEventsSubjectTypeGet
  /*


Returns a paginated list of all valid webhook events for the specified entity.  This is public data that does not require any scopes or authentication.  Example:  NOTE: The following example is a truncated response object for the &#x60;team&#x60; &#x60;subject_type&#x60;. We return the same structure for the other &#x60;subject_type&#x60; objects.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/hook_events/team {     \&quot;page\&quot;: 1,     \&quot;pagelen\&quot;: 30,     \&quot;size\&quot;: 21,     \&quot;values\&quot;: [         {             \&quot;category\&quot;: \&quot;Repository\&quot;,             \&quot;description\&quot;: \&quot;Whenever a repository push occurs\&quot;,             \&quot;event\&quot;: \&quot;repo:push\&quot;,             \&quot;label\&quot;: \&quot;Push\&quot;         },         {             \&quot;category\&quot;: \&quot;Repository\&quot;,             \&quot;description\&quot;: \&quot;Whenever a repository fork occurs\&quot;,             \&quot;event\&quot;: \&quot;repo:fork\&quot;,             \&quot;label\&quot;: \&quot;Fork\&quot;         },         ...         {             \&quot;category\&quot;: \&quot;Repository\&quot;,             \&quot;description\&quot;: \&quot;Whenever a repository import occurs\&quot;,             \&quot;event\&quot;: \&quot;repo:imported\&quot;,             \&quot;label\&quot;: \&quot;Import\&quot;         }     ] } &#x60;&#x60;&#x60;

 */
  hookEventsSubjectTypeGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | A resource or subject type.
    /*let subjectType = "subjectType_example";*/ apiInstance.hookEventsSubjectTypeGet(
      incomingOptions.subjectType,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksGet
  /*


Returns a paginated list of webhooks installed on this repository.

 */
  repositoriesWorkspaceRepoSlugHooksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksUidGet
  /*


Returns the webhook with the specified id installed on the specified repository.

 */
  repositoriesWorkspaceRepoSlugHooksUidGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The installed webhook's id.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let uid = "uid_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksUidGet(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksGet
  /*


Returns a paginated list of webhooks installed on this team.

 */
  teamsUsernameHooksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameHooksGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksUidGet
  /*


Returns the webhook with the specified id installed on the given team account.

 */
  teamsUsernameHooksUidGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id.
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.teamsUsernameHooksUidGet(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksGet
  /*


Returns a paginated list of webhooks installed on this user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameHooksGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksUidGet
  /*


Returns the webhook with the specified id installed on the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksUidGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id.
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.usersUsernameHooksUidGet(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameProjectsGet
  /*


 */
  teamsUsernameProjectsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.ProjectsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameProjectsGet(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameProjectsProjectKeyGet
  /*


 */
  teamsUsernameProjectsProjectKeyGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.ProjectsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The project in question. This can either be the actual `key` assigned to the project or the `UUID` (surrounded by curly-braces (`{}`)).
    /*let username = "username_example";*/ /*let projectKey = "projectKey_example";*/ apiInstance.teamsUsernameProjectsProjectKeyGet(
      incomingOptions.username,
      incomingOptions.projectKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameSshKeysGet
  /*


Returns a specific SSH public key belonging to a user.  Example: &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{fbe4bbab-f6f7-4dde-956b-5c58323c54b3}  {     \&quot;comment\&quot;: \&quot;user@myhost\&quot;,     \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,     \&quot;label\&quot;: \&quot;\&quot;,     \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;         }     },     \&quot;owner\&quot;: {         \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,         \&quot;links\&quot;: {             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;             },             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;             }         },         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;username\&quot;: \&quot;markadams-atl\&quot;,         \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,         \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;     },     \&quot;type\&quot;: \&quot;ssh_key\&quot;,     \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot; } &#x60;&#x60;&#x60;

 */
  usersUsernameSshKeysGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SshApi(); // String | The account's username or UUID // String | The SSH key's UUID value.
    /*let username = "username_example";*/ /*let keyId = "keyId_example";*/ apiInstance.usersUsernameSshKeysGet(
      incomingOptions.username,
      incomingOptions.keyId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameSshKeysGet_0
  /*


Returns a paginated list of the user&#39;s SSH public keys.  Example:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys {     \&quot;page\&quot;: 1,     \&quot;pagelen\&quot;: 10,     \&quot;size\&quot;: 1,     \&quot;values\&quot;: [         {             \&quot;comment\&quot;: \&quot;user@myhost\&quot;,             \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,             \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,             \&quot;label\&quot;: \&quot;\&quot;,             \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,             \&quot;links\&quot;: {                 \&quot;self\&quot;: {                     \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;                 }             },             \&quot;owner\&quot;: {                 \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,                 \&quot;links\&quot;: {                     \&quot;avatar\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;                     },                     \&quot;html\&quot;: {                         \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;                     },                     \&quot;self\&quot;: {                         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;                     }                 },                 \&quot;type\&quot;: \&quot;user\&quot;,                 \&quot;username\&quot;: \&quot;markadams-atl\&quot;,                 \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,                 \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;             },             \&quot;type\&quot;: \&quot;ssh_key\&quot;,             \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot;         }     ] } &#x60;&#x60;&#x60;

 */
  usersUsernameSshKeysGet_0(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SshApi(); // String | The account's UUID, account_id, or username. Note that username has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
    /*let username = "username_example";*/ apiInstance.usersUsernameSshKeysGet_0(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsBranchesGet
  /*


Returns a list of all open branches within the specified repository. Results will be in the order the source control manager returns them.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches | jq . {   \&quot;pagelen\&quot;: 10,   \&quot;values\&quot;: [     {       \&quot;heads\&quot;: [         {           \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,           \&quot;type\&quot;: \&quot;commit\&quot;,           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;             }           }         }       ],       \&quot;type\&quot;: \&quot;named_branch\&quot;,       \&quot;name\&quot;: \&quot;default\&quot;,       \&quot;links\&quot;: {         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default\&quot;         },         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/branch/default\&quot;         }       },       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,         \&quot;repository\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial\&quot;             },             \&quot;avatar\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/avatar/32/\&quot;             }           },           \&quot;type\&quot;: \&quot;repository\&quot;,           \&quot;name\&quot;: \&quot;mercurial\&quot;,           \&quot;full_name\&quot;: \&quot;seanfarley/mercurial\&quot;,           \&quot;uuid\&quot;: \&quot;{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\&quot;         },         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments\&quot;           },           \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;           },           \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve\&quot;           },           \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses\&quot;           }         },         \&quot;author\&quot;: {           \&quot;raw\&quot;: \&quot;Martin von Zweigbergk &lt;martinvonz@google.com&gt;\&quot;,           \&quot;type\&quot;: \&quot;author\&quot;,           \&quot;user\&quot;: {             \&quot;username\&quot;: \&quot;martinvonz\&quot;,             \&quot;nickname\&quot;: \&quot;martinvonz\&quot;,             \&quot;display_name\&quot;: \&quot;Martin von Zweigbergk\&quot;,             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;uuid\&quot;: \&quot;{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/martinvonz\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/martinvonz/\&quot;               },               \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/martinvonz/avatar/32/\&quot;               }             }           }         },         \&quot;parents\&quot;: [           {             \&quot;hash\&quot;: \&quot;5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;,             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;               }             }           }         ],         \&quot;date\&quot;: \&quot;2018-02-01T18:44:49+00:00\&quot;,         \&quot;message\&quot;: \&quot;config: replace a for-else by any()\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;       }     },     {       \&quot;heads\&quot;: [         {           \&quot;hash\&quot;: \&quot;1d60ad093792706e1dc7a52b20942593f2c19655\&quot;,           \&quot;type\&quot;: \&quot;commit\&quot;,           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;             }           }         }       ],       \&quot;type\&quot;: \&quot;named_branch\&quot;,       \&quot;name\&quot;: \&quot;stable\&quot;,       \&quot;links\&quot;: {         \&quot;commits\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/stable\&quot;         },         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/stable\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/branch/stable\&quot;         }       },       \&quot;target\&quot;: {         \&quot;hash\&quot;: \&quot;1d60ad093792706e1dc7a52b20942593f2c19655\&quot;,         \&quot;repository\&quot;: {           \&quot;links\&quot;: {             \&quot;self\&quot;: {               \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\&quot;             },             \&quot;html\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial\&quot;             },             \&quot;avatar\&quot;: {               \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/avatar/32/\&quot;             }           },           \&quot;type\&quot;: \&quot;repository\&quot;,           \&quot;name\&quot;: \&quot;mercurial\&quot;,           \&quot;full_name\&quot;: \&quot;seanfarley/mercurial\&quot;,           \&quot;uuid\&quot;: \&quot;{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\&quot;         },         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;comments\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/comments\&quot;           },           \&quot;patch\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;diff\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/1d60ad093792706e1dc7a52b20942593f2c19655\&quot;           },           \&quot;approve\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/approve\&quot;           },           \&quot;statuses\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/1d60ad093792706e1dc7a52b20942593f2c19655/statuses\&quot;           }         },         \&quot;author\&quot;: {           \&quot;raw\&quot;: \&quot;Augie Fackler &lt;raf@durin42.com&gt;\&quot;,           \&quot;type\&quot;: \&quot;author\&quot;,           \&quot;user\&quot;: {             \&quot;username\&quot;: \&quot;durin42\&quot;,             \&quot;nickname\&quot;: \&quot;durin42\&quot;,             \&quot;display_name\&quot;: \&quot;Augie Fackler\&quot;,             \&quot;type\&quot;: \&quot;user\&quot;,             \&quot;uuid\&quot;: \&quot;{e07dc61f-bb05-4218-b43a-d991f26be65a}\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/durin42\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/durin42/\&quot;               },               \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/durin42/avatar/32/\&quot;               }             }           }         },         \&quot;parents\&quot;: [           {             \&quot;hash\&quot;: \&quot;56a0da11bde519d79168e890df4bcf0da62f0a7b\&quot;,             \&quot;type\&quot;: \&quot;commit\&quot;,             \&quot;links\&quot;: {               \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/56a0da11bde519d79168e890df4bcf0da62f0a7b\&quot;               },               \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/56a0da11bde519d79168e890df4bcf0da62f0a7b\&quot;               }             }           }         ],         \&quot;date\&quot;: \&quot;2018-02-01T19:13:41+00:00\&quot;,         \&quot;message\&quot;: \&quot;Added signature for changeset d334afc585e2\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;       }     }   ],   \&quot;page\&quot;: 1,   \&quot;size\&quot;: 2 } &#x60;&#x60;&#x60;  Branches support [filtering and sorting](../../../../../meta/filtering) that can be used to search for specific branches. For instance, to find all branches that have \&quot;stab\&quot; in their name:  &#x60;&#x60;&#x60; curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches -G --data-urlencode &#39;q&#x3D;name ~ \&quot;stab\&quot;&#39; &#x60;&#x60;&#x60;  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \&quot;$ hg branches\&quot; or \&quot;$ git branch --list\&quot;. Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\&quot;v10\&quot;, \&quot;v11\&quot;, \&quot;v9\&quot;] instead of [\&quot;v9\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;].  Sorting can be changed using the ?q&#x3D; query parameter. When using ?q&#x3D;name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.

 */
  repositoriesWorkspaceRepoSlugRefsBranchesGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String |  This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String |  This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Field by which the results should be sorted as per [filtering and sorting](../../../../../meta/filtering). The `name` field is handled specially for branches in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return ['branch1', 'branch2', 'branch10'] instead of ['branch1', 'branch10', 'branch2'].
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugRefsBranchesGet(
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsBranchesNameGet
  /*


Returns a branch object within the specified repository.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default | jq . {   \&quot;heads\&quot;: [     {       \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,       \&quot;type\&quot;: \&quot;commit\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;         }       }     }   ],   \&quot;type\&quot;: \&quot;named_branch\&quot;,   \&quot;name\&quot;: \&quot;default\&quot;,   \&quot;links\&quot;: {     \&quot;commits\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commits/default\&quot;     },     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/refs/branches/default\&quot;     },     \&quot;html\&quot;: {       \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/branch/default\&quot;     }   },   \&quot;target\&quot;: {     \&quot;hash\&quot;: \&quot;f1a0933ce59e809f190602655e22ae6ec107c397\&quot;,     \&quot;repository\&quot;: {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial\&quot;         },         \&quot;avatar\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/avatar/32/\&quot;         }       },       \&quot;type\&quot;: \&quot;repository\&quot;,       \&quot;name\&quot;: \&quot;mercurial\&quot;,       \&quot;full_name\&quot;: \&quot;seanfarley/mercurial\&quot;,       \&quot;uuid\&quot;: \&quot;{73dcbd61-e506-4fc1-9ecd-31be2b6d6031}\&quot;     },     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;comments\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/comments\&quot;       },       \&quot;patch\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/patch/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;diff\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/diff/f1a0933ce59e809f190602655e22ae6ec107c397\&quot;       },       \&quot;approve\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/approve\&quot;       },       \&quot;statuses\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/f1a0933ce59e809f190602655e22ae6ec107c397/statuses\&quot;       }     },     \&quot;author\&quot;: {       \&quot;raw\&quot;: \&quot;Martin von Zweigbergk &lt;martinvonz@google.com&gt;\&quot;,       \&quot;type\&quot;: \&quot;author\&quot;,       \&quot;user\&quot;: {         \&quot;username\&quot;: \&quot;martinvonz\&quot;,         \&quot;nickname\&quot;: \&quot;martinvonz\&quot;,         \&quot;display_name\&quot;: \&quot;Martin von Zweigbergk\&quot;,         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;uuid\&quot;: \&quot;{fdb0e657-3ade-4fad-a136-95f1ffe4a5ac}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/martinvonz\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/martinvonz/\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/account/martinvonz/avatar/32/\&quot;           }         }       }     },     \&quot;parents\&quot;: [       {         \&quot;hash\&quot;: \&quot;5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/mercurial/commit/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/mercurial/commits/5523aabb85c30ebc2b8e29aadcaf5e13fa92b375\&quot;           }         }       }     ],     \&quot;date\&quot;: \&quot;2018-02-01T18:44:49+00:00\&quot;,     \&quot;message\&quot;: \&quot;config: replace a for-else by any()\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot;   } } &#x60;&#x60;&#x60;  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads).  For Mercurial, the response will include an additional field that lists the open heads.

 */
  repositoriesWorkspaceRepoSlugRefsBranchesNameGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | The name of the branch // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let name = "name_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugRefsBranchesNameGet(
      incomingOptions.name,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsGet
  /*


Returns the branches and tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \&quot;$ git show-ref\&quot;. Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that refs are sorted [\&quot;branch1\&quot;, \&quot;branch10\&quot;, \&quot;branch2\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;, \&quot;v9\&quot;] instead of [\&quot;branch1\&quot;, \&quot;branch2\&quot;, \&quot;branch10\&quot;, \&quot;v9\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;].  Sorting can be changed using the ?sort&#x3D; query parameter. When using ?sort&#x3D;name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.

 */
  repositoriesWorkspaceRepoSlugRefsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String |  This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String |  This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Field by which the results should be sorted as per [filtering and sorting](../../../../meta/filtering). The `name` field is handled specially for refs in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return ['1.1', '1.2', '1.10'] instead of ['1.1', '1.10', '1.2'].
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugRefsGet(
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsTagsGet
  /*


Returns the tags in the repository.  By default, results will be in the order the underlying source control system returns them and identical to the ordering one sees when running \&quot;$ hg tags\&quot; or \&quot;$ git tag --list\&quot;. Note that this follows simple lexical ordering of the ref names.  This can be undesirable as it does apply any natural sorting semantics, meaning for instance that tags are sorted [\&quot;v10\&quot;, \&quot;v11\&quot;, \&quot;v9\&quot;] instead of [\&quot;v9\&quot;, \&quot;v10\&quot;, \&quot;v11\&quot;].  Sorting can be changed using the ?sort&#x3D; query parameter. When using ?sort&#x3D;name to explicitly sort on ref name, Bitbucket will apply natural sorting and interpret numerical values as numbers instead of strings.

 */
  repositoriesWorkspaceRepoSlugRefsTagsGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String |  This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String |  This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'q': "q_example", // String |  Query string to narrow down the response as per [filtering and sorting](../../../../../meta/filtering).
      //  'sort': "sort_example" // String |  Field by which the results should be sorted as per [filtering and sorting](../../../../../meta/filtering). The `name` field is handled specially for tags in that, if specified as the sort field, it uses a natural sort order instead of the default lexicographical sort order. For example, it will return ['1.1', '1.2', '1.10'] instead of ['1.1', '1.10', '1.2'].
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugRefsTagsGet(
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsTagsNameGet
  /*


Returns the specified tag.  &#x60;&#x60;&#x60; $ curl -s https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8 -G | jq . {   \&quot;name\&quot;: \&quot;3.8\&quot;,   \&quot;links\&quot;: {     \&quot;commits\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commits/3.8\&quot;     },     \&quot;self\&quot;: {       \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/tags/3.8\&quot;     },     \&quot;html\&quot;: {       \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/commits/tag/3.8\&quot;     }   },   \&quot;tagger\&quot;: {     \&quot;raw\&quot;: \&quot;Matt Mackall &lt;mpm@selenic.com&gt;\&quot;,     \&quot;type\&quot;: \&quot;author\&quot;,     \&quot;user\&quot;: {       \&quot;username\&quot;: \&quot;mpmselenic\&quot;,       \&quot;nickname\&quot;: \&quot;mpmselenic\&quot;,       \&quot;display_name\&quot;: \&quot;Matt Mackall\&quot;,       \&quot;type\&quot;: \&quot;user\&quot;,       \&quot;uuid\&quot;: \&quot;{a4934530-db4c-419c-a478-9ab4964c2ee7}\&quot;,       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/mpmselenic\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/mpmselenic/\&quot;         },         \&quot;avatar\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/account/mpmselenic/avatar/32/\&quot;         }       }     }   },   \&quot;date\&quot;: \&quot;2016-05-01T18:52:25+00:00\&quot;,   \&quot;message\&quot;: \&quot;Added tag 3.8 for changeset f85de28eae32\&quot;,   \&quot;type\&quot;: \&quot;tag\&quot;,   \&quot;target\&quot;: {     \&quot;hash\&quot;: \&quot;f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;,     \&quot;repository\&quot;: {       \&quot;links\&quot;: {         \&quot;self\&quot;: {           \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg\&quot;         },         \&quot;html\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg\&quot;         },         \&quot;avatar\&quot;: {           \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/avatar/32/\&quot;         }       },       \&quot;type\&quot;: \&quot;repository\&quot;,       \&quot;name\&quot;: \&quot;hg\&quot;,       \&quot;full_name\&quot;: \&quot;seanfarley/hg\&quot;,       \&quot;uuid\&quot;: \&quot;{c75687fb-e99d-4579-9087-190dbd406d30}\&quot;     },     \&quot;links\&quot;: {       \&quot;self\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;comments\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/comments\&quot;       },       \&quot;patch\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/patch/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;html\&quot;: {         \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/commits/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;diff\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/diff/f85de28eae32e7d3064b1a1321309071bbaaa069\&quot;       },       \&quot;approve\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/approve\&quot;       },       \&quot;statuses\&quot;: {         \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/f85de28eae32e7d3064b1a1321309071bbaaa069/statuses\&quot;       }     },     \&quot;author\&quot;: {       \&quot;raw\&quot;: \&quot;Sean Farley &lt;sean@farley.io&gt;\&quot;,       \&quot;type\&quot;: \&quot;author\&quot;,       \&quot;user\&quot;: {         \&quot;username\&quot;: \&quot;seanfarley\&quot;,         \&quot;nickname\&quot;: \&quot;seanfarley\&quot;,         \&quot;display_name\&quot;: \&quot;Sean Farley\&quot;,         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;uuid\&quot;: \&quot;{a295f8a8-5876-4d43-89b5-3ad8c6c3c51d}\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/seanfarley\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/\&quot;           },           \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/account/seanfarley/avatar/32/\&quot;           }         }       }     },     \&quot;parents\&quot;: [       {         \&quot;hash\&quot;: \&quot;9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\&quot;,         \&quot;type\&quot;: \&quot;commit\&quot;,         \&quot;links\&quot;: {           \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/seanfarley/hg/commit/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\&quot;           },           \&quot;html\&quot;: {             \&quot;href\&quot;: \&quot;https://bitbucket.org/seanfarley/hg/commits/9a98d0e5b07fc60887f9d3d34d9ac7d536f470d2\&quot;           }         }       }     ],     \&quot;date\&quot;: \&quot;2016-05-01T04:21:17+00:00\&quot;,     \&quot;message\&quot;: \&quot;debian: alphabetize build deps\&quot;,     \&quot;type\&quot;: \&quot;commit\&quot;   } } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugRefsTagsNameGet(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | The name of the tag // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let name = "name_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugRefsTagsNameGet(
      incomingOptions.name,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  async post(entity, options) {
    switch (entity) {
      case "REPOSITORIES_WORKSPACE_REPO_SLUG_SRC":
        /*



This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  ## multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  ## application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  ## Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugSrcPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USERS_USERNAME_HOOKS":
        /*



Creates a new webhook on the specified user account.  Account-level webhooks are fired for events from all repositories belonging to that account.  Note that one can only register webhooks on one&#39;s own account, not that of others.  Also, note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES_BUILD":
        /*



Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use &#x60;https://foo.com/builds/{repository.full_name}&#x60; which Bitbucket will turn into &#x60;https://foo.com/builds/foo/bar&#x60; at render time. The context variables available are &#x60;repository&#x60; and &#x60;commit&#x60;.


      Function parameters for this API node,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEPLOY_KEYS":
        /*



Create a new deploy key in a repository.  Example: &#x60;&#x60;&#x60; $ curl -XPOST \\ -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ -H \&quot;Content-type: application/json\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ &#39;{     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\&quot;,     \&quot;label\&quot;: \&quot;mydeploykey\&quot; }&#39;  Output: {     \&quot;id\&quot;: 123,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,     \&quot;label\&quot;: \&quot;mydeploykey\&quot;,     \&quot;type\&quot;: \&quot;deploy_key\&quot;,     \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,     \&quot;repository\&quot;: {         \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,         \&quot;name\&quot;: \&quot;test\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;:{         \&quot;self\&quot;:{             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/123\&quot;         }     }     \&quot;last_used\&quot;: null,     \&quot;comment\&quot;: \&quot;mleu@C02W454JHTD8\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDeployKeysPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES_BUILD":
        /*



Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use &#x60;https://foo.com/builds/{repository.full_name}&#x60; which Bitbucket will turn into &#x60;https://foo.com/builds/foo/bar&#x60; at render time. The context variables available are &#x60;repository&#x60; and &#x60;commit&#x60;.


      Function parameters for this API node,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_FORKS":
        /*



Creates a new fork of the specified repository.  ## Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  &#x60;&#x60;&#x60; $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H &#39;Content-Type: application/json&#39; -d &#39;{     \&quot;name\&quot;: \&quot;bbql_fork\&quot;,     \&quot;workspace\&quot;: {       \&quot;slug\&quot;: \&quot;atlassian\&quot;     } }&#39; &#x60;&#x60;&#x60;  To fork a repository into the same workspace, also specify a new &#x60;name&#x60;.  When you specify a value for &#x60;name&#x60;, it will also affect the &#x60;slug&#x60;. The &#x60;slug&#x60; is reflected in the repository URL of the new fork. It is derived from &#x60;name&#x60; by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, &#x60;My repo&#x60; would turn into &#x60;my_repo&#x60;.  You need contributor access to create new forks within a workspace.   ## Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal &#x60;repository&#x60; JSON schema and you can override the new fork&#39;s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo&#39;s fork_policy might prohibit   the creation of public forks, in which &#x60;is_private&#x3D;False&#x60; would fail) * has_issues (to initialize or disable the new repo&#39;s issue tracker --   note that the actual contents of the parent repository&#39;s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo&#39;s wiki --   note that the actual contents of the parent repository&#39;s wiki are not   copied during forking) * project (when forking into a private project, the fork&#39;s &#x60;is_private&#x60;   must be &#x60;true&#x60;)  Properties that cannot be modified include:  * scm * parent * full_name


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugForksPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS":
        /*



Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;           https://api.bitbucket.org/2.0/repositories/username/slug/hooks           -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.


      Function parameters for this API workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG":
        /*



Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;MARS\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  or  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;{ba516952-992a-4c2d-acbd-17d502922f96}\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  The project must only be assigned for repositories belonging to a team. If the repository owner is a team and the project is not provided, the repository is automatically assigned to the oldest project in the team.  Note: In the examples above, the username &#x60;teamsinspace&#x60;, and/or the repository name &#x60;hablanding&#x60; can be replaced by UUIDs.


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_SRC":
        /*



This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  ## multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  ## application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  ## Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugSrcPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_EXPORT":
        /*



A POST request to this endpoint initiates a new background celery task that archives the repo&#39;s issues.  For example, you can run:  curl -u &lt;username&gt; -X POST http://api.bitbucket.org/2.0/repositories/&lt;owner_username&gt;/&lt;repo_slug&gt;/ issues/export  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the &#39;Location&#39; response header. This url is the endpoint for where the user can obtain their zip files.\&quot;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesExportPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_IMPORT":
        /*



A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \&quot;archive,\&quot; which needs to be a file field:  &#x60;&#x60;&#x60; $ curl -u &lt;username&gt; -X POST -F archive&#x3D;@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/&lt;owner_username&gt;/&lt;repo_slug&gt;/issues/import &#x60;&#x60;&#x60;  When the import job is accepted, here is example output:  &#x60;&#x60;&#x60; &lt; HTTP/1.1 202 Accepted  {     \&quot;type\&quot;: \&quot;issue_job_status\&quot;,     \&quot;status\&quot;: \&quot;ACCEPTED\&quot;,     \&quot;phase\&quot;: \&quot;Attachments\&quot;,     \&quot;total\&quot;: 15,     \&quot;count\&quot;: 0,     \&quot;percent\&quot;: 0 } &#x60;&#x60;&#x60;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesImportPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON_LINKERS_LINKER_KEY_VALUES":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyValuesPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON_USERS_TARGET_USER_EVENTS_EVENT_KEY":
        /*



POST a new custom event.  The data within the event body will be hydrated by Bitbucket. For example, the following event submission would result in subscribers for the event receiving the full repository object corresponding to the UUID.  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;mynumdata\&quot;: \&quot;12345\&quot;,     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{be95aa1f-c0b2-47f6-99d1-bf5d3a0f850f}\&quot; }}&#39; https://api.bitbucket.org/2.0/addon/users/myuser/events/com.example.app%3Amyevent &#x60;&#x60;&#x60;  Use the optional &#x60;fields&#x60; property of the custom event Connect module where the event is defined to add additional fields to the expanded payload sent to listeners.  For example, the &#x60;customEvents&#x60; module in the app descriptor for the previous example would look like this:  &#x60;&#x60;&#x60; &#39;modules&#39;: {     &#39;customEvents&#39;: {         &#39;com.example.app:myevent&#39;: {             &#39;schema&#39;: {                 &#39;properties&#39;: {                     &#39;mynumdata&#39;: {&#39;type&#39;: &#39;number&#39;},                     &#39;repository&#39;: {&#39;$ref&#39;: &#39;#/definitions/repository&#39;}                 }             },             &#39;fields&#39;: [&#39;repository.owner&#39;]         }     } } &#x60;&#x60;&#x60;  By specifying fields as above, the repository owner will also be sent to subscribers of the event.


      Function parameters for this API targetUser,eventKey
        */
        return new Promise((resolve, reject) => {
          this.addonUsersTargetUserEventsEventKeyPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "CREATE_DEPLOYMENT_VARI":
        /*



Create a deployment environment level variable.


      Function parameters for this API username,repoSlug,environmentUuid,variableUuid,body
        */
        return new Promise((resolve, reject) => {
          this.createDeploymentVariable(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "CREATE_PIPELINE_FOR_REPOSI":
        /*



Endpoint to create and initiate a pipeline.  There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.  The specified branch will be used to determine which pipeline definition from the &#x60;bitbucket-pipelines.yml&#x60; file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.
      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.createPipelineForRepository(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "CREATE_PIPELINE_VARIABLE_FOR":
        /*



Create an account level variable.


      Function parameters for this API username,opts
        */
        return new Promise((resolve, reject) => {
          this.createPipelineVariableForTeam(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "CREATE_PIPELINE_VARIABLE_FOR":
        /*



Create a user level variable.


      Function parameters for this API username,opts
        */
        return new Promise((resolve, reject) => {
          this.createPipelineVariableForUser(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "CREATE_REPOSITORY_PIPELINE_KNOWN":
        /*



Create a repository level known host.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.createRepositoryPipelineKnownHost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "CREATE_REPOSITORY_PIPELINE_SCHE":
        /*



Create a schedule for the given repository.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.createRepositoryPipelineSchedule(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "CREATE_REPOSITORY_PIPELINE_VARI":
        /*



Create a repository level variable.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.createRepositoryPipelineVariable(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "STOP_PIPE":
        /*



Signal the stop of a pipeline and all of its steps that not have completed yet.


      Function parameters for this API username,repoSlug,pipelineUuid
        */
        return new Promise((resolve, reject) => {
          this.stopPipeline(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_ATTACHMENTS":
        /*



Upload new issue attachments.  To upload files, perform a &#x60;multipart/form-data&#x60; POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.


      Function parameters for this API workspace,repoSlug,issueId
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_CHANGES":
        /*



Makes a change to the specified issue.  For example, to change an issue&#39;s state and assignee, create a new change object that modifies these fields:  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \&quot;Content-Type: application/json\&quot; \\   -d &#39;{     \&quot;changes\&quot;: {       \&quot;assignee_account_id\&quot;: {         \&quot;new\&quot;: \&quot;557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\&quot;       },       \&quot;state\&quot;: {         \&quot;new\&quot;: &#39;resolved\&quot;       }     }     \&quot;message\&quot;: {       \&quot;raw\&quot;: \&quot;This is now resolved.\&quot;     }   }&#39; &#x60;&#x60;&#x60;  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the &#x60;changes&#x60; object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The &#x60;assignee_account_id&#x60; field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user&#39;s account_id in the &#x60;changes.assignee_account_id.new&#x60; field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.


      Function parameters for this API issueId,workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_COMMENTS":
        /*



Creates a new issue comment.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;Lorem ipsum.\&quot;}}&#39; &#x60;&#x60;&#x60;


      Function parameters for this API issueId,workspace,username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES":
        /*



Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue&#39;s &#x60;reporter&#x60; field.


      Function parameters for this API workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCH_RESTRICTIONS":
        /*



Creates a new branch restriction rule for a repository.  &#x60;kind&#x60; describes what will be restricted. Allowed values include: &#x60;push&#x60;, &#x60;force&#x60;, &#x60;delete&#x60; and &#x60;restrict_merges&#x60;.  Different kinds of branch restrictions have different requirements:  * &#x60;push&#x60; and &#x60;restrict_merges&#x60; require &#x60;users&#x60; and &#x60;groups&#x60; to be   specified. Empty lists are allowed, in which case permission is   denied for everybody. * &#x60;force&#x60; can not be specified in a Mercurial repository.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in &#x60;branch_match_kind&#x60;:  1. &#x60;glob&#x60;: Matches a branch against the &#x60;pattern&#x60;. A &#x60;&#39;*&#39;&#x60; in    &#x60;pattern&#x60; will expand to match zero or more characters, and every    other character matches itself. For example, &#x60;&#39;foo*&#39;&#x60; will match    &#x60;&#39;foo&#39;&#x60; and &#x60;&#39;foobar&#39;&#x60;, but not &#x60;&#39;barfoo&#39;&#x60;. &#x60;&#39;*&#39;&#x60; will match all    branches. 2. &#x60;branching_model&#x60;: Matches a branch against the repository&#39;s    branching model. The &#x60;branch_type&#x60; controls the type of branch    to match. Allowed values include: &#x60;production&#x60;, &#x60;development&#x60;,    &#x60;bugfix&#x60;, &#x60;release&#x60;, &#x60;feature&#x60; and &#x60;hotfix&#x60;.  The combination of &#x60;kind&#x60; and match must be unique. This means that two &#x60;glob&#x60; restrictions in a repository cannot have the same &#x60;kind&#x60; and &#x60;pattern&#x60;. Additionally, two &#x60;branching_model&#x60; restrictions in a repository cannot have the same &#x60;kind&#x60; and &#x60;branch_type&#x60;.  &#x60;users&#x60; and &#x60;groups&#x60; are lists of users and groups that are except from the restriction. They can only be configured in &#x60;push&#x60; and &#x60;restrict_merges&#x60; restrictions. The &#x60;push&#x60; restriction stops a user pushing to matching branches unless that user is in &#x60;users&#x60; or is a member of a group in &#x60;groups&#x60;. The &#x60;restrict_merges&#x60; stops a user merging pull requests to matching branches unless that user is in &#x60;users&#x60; or is a member of a group in &#x60;groups&#x60;. Adding new users or groups to an existing restriction should be done via &#x60;PUT&#x60;.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.


      Function parameters for this API workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchRestrictionsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS":
        /*



Creates a new webhook on the specified team.  Team webhooks are fired for events from all repositories belonging to that team account.  Note that only admins can install webhooks on teams.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS":
        /*



Creates a new snippet under the authenticated user&#39;s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file&#x3D;@image.png  Creating snippets through curl has a few limitations and so let&#39;s look at a more complicated scenario.  Snippets are created with a multipart POST. Both &#x60;multipart/form-data&#x60; and &#x60;multipart/related&#x60; are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that &#x60;multipart/related&#x60; can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;is_private\&quot;: true,       \&quot;scm\&quot;: \&quot;hg\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;image.png\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet&#39;s properties or meta data. It either has to be the first part, or the request&#39;s &#x60;Content-Type&#x60; header must contain the &#x60;start&#x60; parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the &#x60;Content-ID&#x60; MIME header through which the JSON meta data&#39;s &#x60;files&#x60; element addresses it. The value should be the name of the file.  &#x60;Content-Disposition&#x60; is an optional MIME header. The header&#39;s optional &#x60;filename&#x60; parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, &#x60;filename&#x60; takes precedence over the value of &#x60;Content-ID&#x60;.  When the JSON body omits the &#x60;files&#x60; element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the &#x60;files&#x60; elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet&#39;s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional &#x60;multipart/form-data&#x60; request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title&#x3D;\&quot;My snippet\&quot;               -F file&#x3D;@foo.txt -F file&#x3D;@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the &#x60;file&#x60; field name. To attach multiple files, simply repeat the field.  The advantage of &#x60;multipart/form-data&#x60; over &#x60;multipart/related&#x60; is that it can be easier to build clients.  Essentially all properties are optional, &#x60;title&#x60; and &#x60;files&#x60; included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to the owner, creator and members of the team in case the snippet is owned by a team). This is controlled through the snippet&#39;s &#x60;is_private&#x60; element:  * **is_private&#x3D;false** -- everyone, including anonymous users can view   the snippet * **is_private&#x3D;true** -- only the owner and team members (for team   snippets) can view it  To create the snippet under a team account, just append the team name to the URL (see &#x60;/2.0/snippets/{username}&#x60;).


      Function parameters for this API body
        */
        return new Promise((resolve, reject) => {
          this.snippetsPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMENTS":
        /*



Creates a new comment.  The only required field in the body is &#x60;content.raw&#x60;.  To create a threaded reply to an existing comment, include &#x60;parent.id&#x60;.


      Function parameters for this API encodedId,workspace,body
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommentsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE":
        /*



Identical to &#x60;/snippets&#x60;, except that the new snippet will be created under the account specified in the path parameter &#x60;{workspace}&#x60;.


      Function parameters for this API workspace,body
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspacePost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS":
        /*



Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are &#x60;title&#x60; and &#x60;source&#x60;, specified by a branch name.  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header &#39;Content-Type: application/json&#39; \\     --data &#39;{         \&quot;title\&quot;: \&quot;My Title\&quot;,         \&quot;source\&quot;: {             \&quot;branch\&quot;: {                 \&quot;name\&quot;: \&quot;staging\&quot;             }         }     }&#39; &#x60;&#x60;&#x60;  If the pull request&#39;s &#x60;destination&#x60; is not specified, it will default to the &#x60;repository.mainbranch&#x60;. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a &#x60;destination&#x60; (same format as the &#x60;source&#x60;):  &#x60;&#x60;&#x60; {     \&quot;title\&quot;: \&quot;My Title\&quot;,     \&quot;source\&quot;: {         \&quot;branch\&quot;: {             \&quot;name\&quot;: \&quot;my-feature-branch\&quot;         }     },     \&quot;destination\&quot;: {         \&quot;branch\&quot;: {             \&quot;name\&quot;: \&quot;staging\&quot;         }     } } &#x60;&#x60;&#x60;  Reviewers can be specified by adding an array of user objects as the &#x60;reviewers&#x60; property.  &#x60;&#x60;&#x60; {     \&quot;title\&quot;: \&quot;My Title\&quot;,     \&quot;source\&quot;: {         \&quot;branch\&quot;: {             \&quot;name\&quot;: \&quot;my-feature-branch\&quot;         }     },     \&quot;reviewers\&quot;: [         {             \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;         }     ] } &#x60;&#x60;&#x60;  Other fields:  * &#x60;description&#x60; - a string * &#x60;close_source_branch&#x60; - boolean that specifies if the source branch should be closed upon merging


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_APPROVE":
        /*



Approve the specified pull request as the authenticated user.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_COMMENTS":
        /*



Creates a new pull request comment.  Returns the newly created pull request comment.


      Function parameters for this API workspace,repoSlug,pullRequestId,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_DECLINE":
        /*



Declines the pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_MERGE":
        /*



Merges the pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DOWNLOADS":
        /*



Upload new download artifacts.  To upload files, perform a &#x60;multipart/form-data&#x60; POST containing one or more &#x60;files&#x60; fields:      $ echo Hello World &gt; hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files&#x3D;@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDownloadsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_APPROVE":
        /*



Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.


      Function parameters for this API node,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeApprovePost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_COMMENTS":
        /*



Creates new comment on the specified commit.  To post a reply to an existing comment, include the &#x60;parent.id&#x60; field:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;},        \&quot;parent\&quot;: {\&quot;id\&quot;: 5728901}}&#39; &#x60;&#x60;&#x60;


      Function parameters for this API node,workspace,username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeCommentsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMITS":
        /*



Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMITS_REVISION":
        /*



Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**


      Function parameters for this API revision,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitsRevisionPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "CREATE_ENVIRON":
        /*



Create an environment.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.createEnvironment(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_ENVIRONMENT_FOR_REPOSI":
        /*



Update an environment


      Function parameters for this API username,repoSlug,environmentUuid
        */
        return new Promise((resolve, reject) => {
          this.updateEnvironmentForRepository(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS":
        /*



Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;           https://api.bitbucket.org/2.0/repositories/username/slug/hooks           -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.


      Function parameters for this API workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS":
        /*



Creates a new webhook on the specified team.  Team webhooks are fired for events from all repositories belonging to that team account.  Note that only admins can install webhooks on teams.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS":
        /*



Creates a new webhook on the specified user account.  Account-level webhooks are fired for events from all repositories belonging to that account.  Note that one can only register webhooks on one&#39;s own account, not that of others.  Also, note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_PROJECTS":
        /*



Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  &#x60;&#x60;&#x60; $ body&#x3D;$(cat &lt;&lt; EOF {     \&quot;name\&quot;: \&quot;Mars Project\&quot;,     \&quot;key\&quot;: \&quot;MARS\&quot;,     \&quot;description\&quot;: \&quot;Software for colonizing mars.\&quot;,     \&quot;links\&quot;: {         \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\&quot;         }     },     \&quot;is_private\&quot;: false } EOF ) $ curl -H \&quot;Content-Type: application/json\&quot; \\        -X POST \\        -d \&quot;$body\&quot; \\        https://api.bitbucket.org/2.0/teams/teams-in-space/projects/ | jq . {   // Serialized project document } &#x60;&#x60;&#x60;  or even:  &#x60;&#x60;&#x60; $ body&#x3D;$(cat &lt;&lt; EOF {     \&quot;name\&quot;: \&quot;Mars Project\&quot;,     \&quot;key\&quot;: \&quot;MARS\&quot;,     \&quot;description\&quot;: \&quot;Software for colonizing mars.\&quot;,     \&quot;links\&quot;: {         \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;http://i.imgur.com/72tRx4w.gif\&quot;         }     },     \&quot;is_private\&quot;: false } EOF ) $ curl -H \&quot;Content-Type: application/json\&quot; \\        -X POST \\        -d \&quot;$body\&quot; \\        https://api.bitbucket.org/2.0/teams/teams-in-space/projects/ | jq . {   // Serialized project document } &#x60;&#x60;&#x60;


      Function parameters for this API username,body
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameProjectsPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_SSH_KEYS":
        /*



Adds a new SSH public key to the specified user account and returns the resulting key.  Example: &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\&quot;}&#39; https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys  {     \&quot;comment\&quot;: \&quot;user@myhost\&quot;,     \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,     \&quot;label\&quot;: \&quot;\&quot;,     \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;         }     },     \&quot;owner\&quot;: {         \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,         \&quot;links\&quot;: {             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;             },             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;             }         },         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;username\&quot;: \&quot;markadams-atl\&quot;,         \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,         \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;     },     \&quot;type\&quot;: \&quot;ssh_key\&quot;,     \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API username,opts
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameSshKeysPost(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_BRANCHES":
        /*



Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \&quot;Content-Type: application/json\&quot; \\ -d &#39;{     \&quot;name\&quot; : \&quot;smf/create-feature\&quot;,     \&quot;target\&quot; : {         \&quot;hash\&quot; : \&quot;default\&quot;,     } }&#39; &#x60;&#x60;&#x60;  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.  For Mercurial, the authenticated user making this call is the author of the new branch commit and the date is current datetime of the call.


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsBranchesPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_TAGS":
        /*



Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \&quot;Content-Type: application/json\&quot; \\ -d &#39;{     \&quot;name\&quot; : \&quot;new-tag-name\&quot;,     \&quot;target\&quot; : {         \&quot;hash\&quot; : \&quot;a1b2c3d4e5f6\&quot;,     } }&#39; &#x60;&#x60;&#x60;  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.


      Function parameters for this API workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsTagsPost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      default:
        throw ErrorHelper.getError(`Can't get entity`, 404);
    }
  }
  // This is a function for repositoriesWorkspaceRepoSlugSrcPost
  /*


This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  ## multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  ## application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  ## Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.

 */
  repositoriesWorkspaceRepoSlugSrcPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SourceApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'message': "message_example", // String | The commit message. When omitted, Bitbucket uses a canned string.
      //  'author': "author_example", // String |  The raw string to be used as the new commit's author. This string follows the format `Erik van Zijst <evzijst@atlassian.com>`.  When omitted, Bitbucket uses the authenticated user's full/display name and primary email address. Commits cannot be created anonymously.
      //  'parents': "parents_example", // String |  A comma-separated list of SHA1s of the commits that should be the parents of the newly created commit.  When omitted, the new commit will inherit from and become a child of the main branch's tip/HEAD commit.  When more than one SHA1 is provided, the first SHA1 identifies the commit from which the content will be inherited.  When more than 2 parents are provided on a Mercurial repo, a 400 is returned as Mercurial does not support \"octopus merges\".
      //  'files': "files_example", // String |  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this `files` meta data field is redundant. However, when the `files` field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit.
      //  'files2': "files_example", // String |  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch's new HEAD/tip.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, if a parent SHA1 was also provided, then it is asserted that the parent is the branch's tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  This API cannot be used to create new anonymous heads in Mercurial repos.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch's tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request also specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch's current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo's root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo's root commit and also define the repo's main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with parents, but omitting the files fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.
      //  'branch': "branch_example" // String |  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch's new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch's tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  This API cannot be used to create new anonymous heads in Mercurial repositories.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch's tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch's current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo's root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo's root commit and also define the repo's main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with `parents`, but omitting the `files` fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugSrcPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksPost
  /*


Creates a new webhook on the specified user account.  Account-level webhooks are fired for events from all repositories belonging to that account.  Note that one can only register webhooks on one&#39;s own account, not that of others.  Also, note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameHooksPost(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost
  /*


Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use &#x60;https://foo.com/builds/{repository.full_name}&#x60; which Bitbucket will turn into &#x60;https://foo.com/builds/foo/bar&#x60; at render time. The context variables available are &#x60;repository&#x60; and &#x60;commit&#x60;.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitstatusesApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Commitstatus() // Commitstatus | The new commit status object.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDeployKeysPost
  /*


Create a new deploy key in a repository.  Example: &#x60;&#x60;&#x60; $ curl -XPOST \\ -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ -H \&quot;Content-type: application/json\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys -d \\ &#39;{     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 mleu@C02W454JHTD8\&quot;,     \&quot;label\&quot;: \&quot;mydeploykey\&quot; }&#39;  Output: {     \&quot;id\&quot;: 123,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,     \&quot;label\&quot;: \&quot;mydeploykey\&quot;,     \&quot;type\&quot;: \&quot;deploy_key\&quot;,     \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,     \&quot;repository\&quot;: {         \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,         \&quot;name\&quot;: \&quot;test\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;links\&quot;:{         \&quot;self\&quot;:{             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/123\&quot;         }     }     \&quot;last_used\&quot;: null,     \&quot;comment\&quot;: \&quot;mleu@C02W454JHTD8\&quot; } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugDeployKeysPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DeployApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDeployKeysPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost
  /*


Creates a new build status against the specified commit.  If the specified key already exists, the existing status object will be overwritten.  When creating a new commit status, you can use a URI template for the URL. Templates are URLs that contain variable names that Bitbucket will evaluate at runtime whenever the URL is displayed anywhere similar to parameter substitution in [Bitbucket Connect](https://developer.atlassian.com/bitbucket/concepts/context-parameters.html). For example, one could use &#x60;https://foo.com/builds/{repository.full_name}&#x60; which Bitbucket will turn into &#x60;https://foo.com/builds/foo/bar&#x60; at render time. The context variables available are &#x60;repository&#x60; and &#x60;commit&#x60;.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Commitstatus() // Commitstatus | The new commit status object.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildPost(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugForksPost
  /*


Creates a new fork of the specified repository.  ## Forking a repository  To create a fork, specify the workspace explicitly as part of the request body:  &#x60;&#x60;&#x60; $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \\   -H &#39;Content-Type: application/json&#39; -d &#39;{     \&quot;name\&quot;: \&quot;bbql_fork\&quot;,     \&quot;workspace\&quot;: {       \&quot;slug\&quot;: \&quot;atlassian\&quot;     } }&#39; &#x60;&#x60;&#x60;  To fork a repository into the same workspace, also specify a new &#x60;name&#x60;.  When you specify a value for &#x60;name&#x60;, it will also affect the &#x60;slug&#x60;. The &#x60;slug&#x60; is reflected in the repository URL of the new fork. It is derived from &#x60;name&#x60; by substituting non-ASCII characters, removes whitespace, and changes characters to lower case. For example, &#x60;My repo&#x60; would turn into &#x60;my_repo&#x60;.  You need contributor access to create new forks within a workspace.   ## Change the properties of a new fork  By default the fork inherits most of its properties from the parent. However, since the optional POST body document follows the normal &#x60;repository&#x60; JSON schema and you can override the new fork&#39;s properties.  Properties that can be overridden include:  * description * fork_policy * language * mainbranch * is_private (note that a private repo&#39;s fork_policy might prohibit   the creation of public forks, in which &#x60;is_private&#x3D;False&#x60; would fail) * has_issues (to initialize or disable the new repo&#39;s issue tracker --   note that the actual contents of the parent repository&#39;s issue   tracker are not copied during forking) * has_wiki (to initialize or disable the new repo&#39;s wiki --   note that the actual contents of the parent repository&#39;s wiki are not   copied during forking) * project (when forking into a private project, the fork&#39;s &#x60;is_private&#x60;   must be &#x60;true&#x60;)  Properties that cannot be modified include:  * scm * parent * full_name

 */
  repositoriesWorkspaceRepoSlugForksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Repository() // Repository | A repository object. This can be left blank.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugForksPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksPost
  /*


Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;           https://api.bitbucket.org/2.0/repositories/username/slug/hooks           -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.

 */
  repositoriesWorkspaceRepoSlugHooksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // HookBody |
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.HookBody();*/ apiInstance.repositoriesWorkspaceRepoSlugHooksPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPost
  /*


Creates a new repository.  Note: In order to set the project for the newly created repository, pass in either the project key or the project UUID as part of the request body as shown in the examples below:  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;MARS\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  or  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;scm\&quot;: \&quot;git\&quot;,     \&quot;project\&quot;: {         \&quot;key\&quot;: \&quot;{ba516952-992a-4c2d-acbd-17d502922f96}\&quot;     } }&#39; https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding &#x60;&#x60;&#x60;  The project must only be assigned for repositories belonging to a team. If the repository owner is a team and the project is not provided, the repository is automatically assigned to the oldest project in the team.  Note: In the examples above, the username &#x60;teamsinspace&#x60;, and/or the repository name &#x60;hablanding&#x60; can be replaced by UUIDs.

 */
  repositoriesWorkspaceRepoSlugPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Repository() // Repository | The repository that is to be created. Note that most object elements are optional. Elements \"owner\" and \"full_name\" are ignored as the URL implies them.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugSrcPost
  /*


This endpoint is used to create new commits in the repository by uploading files.  To add a new file to a repository:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F /repo/path/to/image.png&#x3D;@image.png &#x60;&#x60;&#x60;  This will create a new commit on top of the main branch, inheriting the contents of the main branch, but adding (or overwriting) the &#x60;image.png&#x60; file to the repository in the &#x60;/repo/path/to&#x60; directory.  To create a commit that deletes files, use the &#x60;files&#x60; parameter:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \\   -F files&#x3D;/file/to/delete/1.txt \\   -F files&#x3D;/file/to/delete/2.txt &#x60;&#x60;&#x60;  You can add/modify/delete multiple files in a request. Rename/move a file by deleting the old path and adding the content at the new path.  This endpoint accepts &#x60;multipart/form-data&#x60; (as in the examples above), as well as &#x60;application/x-www-form-urlencoded&#x60;.  ## multipart/form-data  A &#x60;multipart/form-data&#x60; post contains a series of \&quot;form fields\&quot; that identify both the individual files that are being uploaded, as well as additional, optional meta data.  Files are uploaded in file form fields (those that have a &#x60;Content-Disposition&#x60; parameter) whose field names point to the remote path in the repository where the file should be stored. Path field names are always interpreted to be absolute from the root of the repository, regardless whether the client uses a leading slash (as the above &#x60;curl&#x60; example did).  File contents are treated as bytes and are not decoded as text.  The commit message, as well as other non-file meta data for the request, is sent along as normal form field elements. Meta data fields share the same namespace as the file objects. For &#x60;multipart/form-data&#x60; bodies that should not lead to any ambiguity, as the &#x60;Content-Disposition&#x60; header will contain the &#x60;filename&#x60; parameter to distinguish between a file named \&quot;message\&quot; and the commit message field.  ## application/x-www-form-urlencoded  It is also possible to upload new files using a simple &#x60;application/x-www-form-urlencoded&#x60; POST. This can be convenient when uploading pure text files:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \\   --data-urlencode \&quot;/path/to/me.txt&#x3D;Lorem ipsum.\&quot; \\   --data-urlencode \&quot;message&#x3D;Initial commit\&quot; \\   --data-urlencode \&quot;author&#x3D;Erik van Zijst &lt;erik.van.zijst@gmail.com&gt;\&quot; &#x60;&#x60;&#x60;  There could be a field name clash if a client were to upload a file named \&quot;message\&quot;, as this filename clashes with the meta data property for the commit message. To avoid this and to upload files whose names clash with the meta data properties, use a leading slash for the files, e.g. &#x60;curl --data-urlencode \&quot;/message&#x3D;file contents\&quot;&#x60;.  When an explicit slash is omitted for a file whose path matches that of a meta data parameter, then it is interpreted as meta data, not as a file.  ## Executables and links  While this API aims to facilitate the most common use cases, it is possible to perform some more advanced operations like creating a new symlink in the repository, or creating an executable file.  Files can be supplied with a &#x60;x-attributes&#x60; value in the &#x60;Content-Disposition&#x60; header. For example, to upload an executable file, as well as create a symlink from &#x60;README.txt&#x60; to &#x60;README&#x60;:  &#x60;&#x60;&#x60; --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;bin/shutdown.sh\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;shutdown.sh\&quot;; x-attributes:\&quot;executable\&quot;  #!/bin/sh halt  --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D; Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit Content-ID: \&quot;/README.txt\&quot; Content-Disposition: attachment; filename&#x3D;\&quot;README.txt\&quot;; x-attributes:\&quot;link\&quot;  README --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;-- &#x60;&#x60;&#x60;  Links are files that contain the target path and have &#x60;x-attributes:\&quot;link\&quot;&#x60; set.  When overwriting links with files, or vice versa, the newly uploaded file determines both the new contents, as well as the attributes. That means uploading a file without specifying &#x60;x-attributes&#x3D;\&quot;link\&quot;&#x60; will create a regular file, even if the parent commit hosted a symlink at the same path.  The same applies to executables. When modifying an existing executable file, the form-data file element must include &#x60;x-attributes&#x3D;\&quot;executable\&quot;&#x60; in order to preserve the executable status of the file.  Note that this API does not support the creation or manipulation of subrepos / submodules.

 */
  repositoriesWorkspaceRepoSlugSrcPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'message': "message_example", // String | The commit message. When omitted, Bitbucket uses a canned string.
      //  'author': "author_example", // String |  The raw string to be used as the new commit's author. This string follows the format `Erik van Zijst <evzijst@atlassian.com>`.  When omitted, Bitbucket uses the authenticated user's full/display name and primary email address. Commits cannot be created anonymously.
      //  'parents': "parents_example", // String |  A comma-separated list of SHA1s of the commits that should be the parents of the newly created commit.  When omitted, the new commit will inherit from and become a child of the main branch's tip/HEAD commit.  When more than one SHA1 is provided, the first SHA1 identifies the commit from which the content will be inherited.  When more than 2 parents are provided on a Mercurial repo, a 400 is returned as Mercurial does not support \"octopus merges\".
      //  'files': "files_example", // String |  Optional field that declares the files that the request is manipulating. When adding a new file to a repo, or when overwriting an existing file, the client can just upload the full contents of the file in a normal form field and the use of this `files` meta data field is redundant. However, when the `files` field contains a file path that does not have a corresponding, identically-named form field, then Bitbucket interprets that as the client wanting to replace the named file with the null set and the file is deleted instead.  Paths in the repo that are referenced in neither files nor an individual file field, remain unchanged and carry over from the parent to the new commit.  This API does not support renaming as an explicit feature. To rename a file, simply delete it and recreate it under the new name in the same commit.
      //  'files2': "files_example", // String |  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch's new HEAD/tip.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, if a parent SHA1 was also provided, then it is asserted that the parent is the branch's tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  This API cannot be used to create new anonymous heads in Mercurial repos.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch's tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request also specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch's current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo's root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo's root commit and also define the repo's main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with parents, but omitting the files fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.
      //  'branch': "branch_example" // String |  The name of the branch that the new commit should be created on. When omitted, the commit will be created on top of the main branch and will become the main branch's new head.  When a branch name is provided that already exists in the repo, then the commit will be created on top of that branch. In this case, *if* a parent SHA1 was also provided, then it is asserted that the parent is the branch's tip/HEAD at the time the request is made. When this is not the case, a 409 is returned.  This API cannot be used to create new anonymous heads in Mercurial repositories.  When a new branch name is specified (that does not already exist in the repo), and no parent SHA1s are provided, then the new commit will inherit from the current main branch's tip/HEAD commit, but not advance the main branch. The new commit will be the new branch. When the request *also* specifies a parent SHA1, then the new commit and branch are created directly on top of the parent commit, regardless of the state of the main branch.  When a branch name is not specified, but a parent SHA1 is provided, then Bitbucket asserts that it represents the main branch's current HEAD/tip, or a 409 is returned.  When a branch name is not specified and the repo is empty, the new commit will become the repo's root commit and will be on the main branch.  When a branch name is specified and the repo is empty, the new commit will become the repo's root commit and also define the repo's main branch going forward.  This API cannot be used to create additional root commits in non-empty repos.  The branch field cannot be repeated.  As a side effect, this API can be used to create a new branch without modifying any files, by specifying a new branch name in this field, together with `parents`, but omitting the `files` fields, while not sending any files. This will create a new commit and branch with the same contents as the first parent. The diff of this commit against its first parent will be empty.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugSrcPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesExportPost
  /*


A POST request to this endpoint initiates a new background celery task that archives the repo&#39;s issues.  For example, you can run:  curl -u &lt;username&gt; -X POST http://api.bitbucket.org/2.0/repositories/&lt;owner_username&gt;/&lt;repo_slug&gt;/ issues/export  When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the &#39;Location&#39; response header. This url is the endpoint for where the user can obtain their zip files.\&quot;

 */
  repositoriesWorkspaceRepoSlugIssuesExportPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesExportPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesImportPost
  /*


A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All existing issues will be deleted and replaced by the contents of the imported zip file.  Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name \&quot;archive,\&quot; which needs to be a file field:  &#x60;&#x60;&#x60; $ curl -u &lt;username&gt; -X POST -F archive&#x3D;@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/&lt;owner_username&gt;/&lt;repo_slug&gt;/issues/import &#x60;&#x60;&#x60;  When the import job is accepted, here is example output:  &#x60;&#x60;&#x60; &lt; HTTP/1.1 202 Accepted  {     \&quot;type\&quot;: \&quot;issue_job_status\&quot;,     \&quot;status\&quot;: \&quot;ACCEPTED\&quot;,     \&quot;phase\&quot;: \&quot;Attachments\&quot;,     \&quot;total\&quot;: 15,     \&quot;count\&quot;: 0,     \&quot;percent\&quot;: 0 } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugIssuesImportPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DefaultApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesImportPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonLinkersLinkerKeyValuesPost
  /*


 */
  addonLinkersLinkerKeyValuesPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyValuesPost(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonUsersTargetUserEventsEventKeyPost
  /*


POST a new custom event.  The data within the event body will be hydrated by Bitbucket. For example, the following event submission would result in subscribers for the event receiving the full repository object corresponding to the UUID.  &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{     \&quot;mynumdata\&quot;: \&quot;12345\&quot;,     \&quot;repository\&quot;: {         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{be95aa1f-c0b2-47f6-99d1-bf5d3a0f850f}\&quot; }}&#39; https://api.bitbucket.org/2.0/addon/users/myuser/events/com.example.app%3Amyevent &#x60;&#x60;&#x60;  Use the optional &#x60;fields&#x60; property of the custom event Connect module where the event is defined to add additional fields to the expanded payload sent to listeners.  For example, the &#x60;customEvents&#x60; module in the app descriptor for the previous example would look like this:  &#x60;&#x60;&#x60; &#39;modules&#39;: {     &#39;customEvents&#39;: {         &#39;com.example.app:myevent&#39;: {             &#39;schema&#39;: {                 &#39;properties&#39;: {                     &#39;mynumdata&#39;: {&#39;type&#39;: &#39;number&#39;},                     &#39;repository&#39;: {&#39;$ref&#39;: &#39;#/definitions/repository&#39;}                 }             },             &#39;fields&#39;: [&#39;repository.owner&#39;]         }     } } &#x60;&#x60;&#x60;  By specifying fields as above, the repository owner will also be sent to subscribers of the event.

 */
  addonUsersTargetUserEventsEventKeyPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String | The account the app is installed in.  This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The key of the event, which corresponds to an event defined in the connect app descriptor.
    /*let targetUser = "targetUser_example";*/ /*let eventKey = "eventKey_example";*/ apiInstance.addonUsersTargetUserEventsEventKeyPost(
      incomingOptions.targetUser,
      incomingOptions.eventKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for createDeploymentVariable
  /*


Create a deployment environment level variable.

 */
  createDeploymentVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The environment // String | The UUID of the variable to update // DeploymentVariable | The variable to create
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ /*let variableUuid = "variableUuid_example";*/ /*let body = new Bitbucket.DeploymentVariable();*/ apiInstance.createDeploymentVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      incomingOptions.variableUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createPipelineForRepository
  /*


Endpoint to create and initiate a pipeline.  There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated. # Trigger a Pipeline for a branch One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.  The specified branch will be used to determine which pipeline definition from the &#x60;bitbucket-pipelines.yml&#x60; file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.   */
  createPipelineForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // Pipeline | The pipeline to initiate.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.Pipeline();*/ apiInstance.createPipelineForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createPipelineVariableForTeam
  /*


Create an account level variable.

 */
  createPipelineVariableForTeam(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account.
    /*let username = "username_example";*/ let opts = {
      body: new Bitbucket.PipelineVariable() // PipelineVariable | The variable to create.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.createPipelineVariableForTeam(
      incomingOptions.username,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createPipelineVariableForUser
  /*


Create a user level variable.

 */
  createPipelineVariableForUser(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account.
    /*let username = "username_example";*/ let opts = {
      body: new Bitbucket.PipelineVariable() // PipelineVariable | The variable to create.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.createPipelineVariableForUser(
      incomingOptions.username,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createRepositoryPipelineKnownHost
  /*


Create a repository level known host.

 */
  createRepositoryPipelineKnownHost(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // PipelineKnownHost | The known host to create.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PipelineKnownHost();*/ apiInstance.createRepositoryPipelineKnownHost(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createRepositoryPipelineSchedule
  /*


Create a schedule for the given repository.

 */
  createRepositoryPipelineSchedule(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // PipelineSchedule | The schedule to create.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PipelineSchedule();*/ apiInstance.createRepositoryPipelineSchedule(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createRepositoryPipelineVariable
  /*


Create a repository level variable.

 */
  createRepositoryPipelineVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // PipelineVariable | The variable to create.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PipelineVariable();*/ apiInstance.createRepositoryPipelineVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for stopPipeline
  /*


Signal the stop of a pipeline and all of its steps that not have completed yet.

 */
  stopPipeline(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the pipeline.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pipelineUuid = "pipelineUuid_example";*/ apiInstance.stopPipeline(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pipelineUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost
  /*


Upload new issue attachments.  To upload files, perform a &#x60;multipart/form-data&#x60; POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Number | The issue's id
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let issueId = 56;*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.issueId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost
  /*


Makes a change to the specified issue.  For example, to change an issue&#39;s state and assignee, create a new change object that modifies these fields:  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \&quot;Content-Type: application/json\&quot; \\   -d &#39;{     \&quot;changes\&quot;: {       \&quot;assignee_account_id\&quot;: {         \&quot;new\&quot;: \&quot;557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\&quot;       },       \&quot;state\&quot;: {         \&quot;new\&quot;: &#39;resolved\&quot;       }     }     \&quot;message\&quot;: {       \&quot;raw\&quot;: \&quot;This is now resolved.\&quot;     }   }&#39; &#x60;&#x60;&#x60;  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the &#x60;changes&#x60; object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The &#x60;assignee_account_id&#x60; field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user&#39;s account_id in the &#x60;changes.assignee_account_id.new&#x60; field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // IssueChange | The new issue state change. The only required elements are `changes.[].new`. All other elements can be omitted from the body.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.IssueChange();*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdChangesPost(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost
  /*


Creates a new issue comment.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;Lorem ipsum.\&quot;}}&#39; &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // IssueComment | The new issue comment object.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.IssueComment();*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsPost(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesPost
  /*


Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue&#39;s &#x60;reporter&#x60; field.

 */
  repositoriesWorkspaceRepoSlugIssuesPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Issue | The new issue. The only required element is `title`. All other elements can be omitted from the body.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.Issue();*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchRestrictionsPost
  /*


Creates a new branch restriction rule for a repository.  &#x60;kind&#x60; describes what will be restricted. Allowed values include: &#x60;push&#x60;, &#x60;force&#x60;, &#x60;delete&#x60; and &#x60;restrict_merges&#x60;.  Different kinds of branch restrictions have different requirements:  * &#x60;push&#x60; and &#x60;restrict_merges&#x60; require &#x60;users&#x60; and &#x60;groups&#x60; to be   specified. Empty lists are allowed, in which case permission is   denied for everybody. * &#x60;force&#x60; can not be specified in a Mercurial repository.  The restriction applies to all branches that match. There are two ways to match a branch. It is configured in &#x60;branch_match_kind&#x60;:  1. &#x60;glob&#x60;: Matches a branch against the &#x60;pattern&#x60;. A &#x60;&#39;*&#39;&#x60; in    &#x60;pattern&#x60; will expand to match zero or more characters, and every    other character matches itself. For example, &#x60;&#39;foo*&#39;&#x60; will match    &#x60;&#39;foo&#39;&#x60; and &#x60;&#39;foobar&#39;&#x60;, but not &#x60;&#39;barfoo&#39;&#x60;. &#x60;&#39;*&#39;&#x60; will match all    branches. 2. &#x60;branching_model&#x60;: Matches a branch against the repository&#39;s    branching model. The &#x60;branch_type&#x60; controls the type of branch    to match. Allowed values include: &#x60;production&#x60;, &#x60;development&#x60;,    &#x60;bugfix&#x60;, &#x60;release&#x60;, &#x60;feature&#x60; and &#x60;hotfix&#x60;.  The combination of &#x60;kind&#x60; and match must be unique. This means that two &#x60;glob&#x60; restrictions in a repository cannot have the same &#x60;kind&#x60; and &#x60;pattern&#x60;. Additionally, two &#x60;branching_model&#x60; restrictions in a repository cannot have the same &#x60;kind&#x60; and &#x60;branch_type&#x60;.  &#x60;users&#x60; and &#x60;groups&#x60; are lists of users and groups that are except from the restriction. They can only be configured in &#x60;push&#x60; and &#x60;restrict_merges&#x60; restrictions. The &#x60;push&#x60; restriction stops a user pushing to matching branches unless that user is in &#x60;users&#x60; or is a member of a group in &#x60;groups&#x60;. The &#x60;restrict_merges&#x60; stops a user merging pull requests to matching branches unless that user is in &#x60;users&#x60; or is a member of a group in &#x60;groups&#x60;. Adding new users or groups to an existing restriction should be done via &#x60;PUT&#x60;.  Note that branch restrictions with overlapping matchers is allowed, but the resulting behavior may be surprising.

 */
  repositoriesWorkspaceRepoSlugBranchRestrictionsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchrestrictionsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Branchrestriction | The new rule
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.Branchrestriction();*/ apiInstance.repositoriesWorkspaceRepoSlugBranchRestrictionsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksPost
  /*


Creates a new webhook on the specified team.  Team webhooks are fired for events from all repositories belonging to that team account.  Note that only admins can install webhooks on teams.

 */
  teamsUsernameHooksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameHooksPost(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsPost
  /*


Creates a new snippet under the authenticated user&#39;s account.  Snippets can contain multiple files. Both text and binary files are supported.  The simplest way to create a new snippet from a local file:      $ curl -u username:password -X POST https://api.bitbucket.org/2.0/snippets               -F file&#x3D;@image.png  Creating snippets through curl has a few limitations and so let&#39;s look at a more complicated scenario.  Snippets are created with a multipart POST. Both &#x60;multipart/form-data&#x60; and &#x60;multipart/related&#x60; are supported. Both allow the creation of snippets with both meta data (title, etc), as well as multiple text and binary files.  The main difference is that &#x60;multipart/related&#x60; can use rich encoding for the meta data (currently JSON).   multipart/related (RFC-2387) ----------------------------  This is the most advanced and efficient way to create a paste.      POST /2.0/snippets/evzijst HTTP/1.1     Content-Length: 1188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My snippet\&quot;,       \&quot;is_private\&quot;: true,       \&quot;scm\&quot;: \&quot;hg\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;image.png\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: image/png     MIME-Version: 1.0     Content-Transfer-Encoding: base64     Content-ID: \&quot;image.png\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;image.png\&quot;      iVBORw0KGgoAAAANSUhEUgAAABQAAAAoCAYAAAD+MdrbAAABD0lEQVR4Ae3VMUoDQRTG8ccUaW2m     TKONFxArJYJamCvkCnZTaa+VnQdJSBFl2SMsLFrEWNjZBZs0JgiL/+KrhhVmJRbCLPx4O+/DT2TB     cbblJxf+UWFVVRNsEGAtgvJxnLm2H+A5RQ93uIl+3632PZyl/skjfOn9Gvdwmlcw5aPUwimG+NT5     EnNN036IaZePUuIcK533NVfal7/5yjWeot2z9ta1cAczHEf7I+3J0ws9Cgx0fsOFpmlfwKcWPuBQ     73Oc4FHzBaZ8llq4q1mr5B2mOUCt815qYR8eB1hG2VJ7j35q4RofaH7IG+Xrf/PfJhfmwtfFYoIN     AqxFUD6OMxcvkO+UfKfkOyXfKdsv/AYCHMLVkHAFWgAAAABJRU5ErkJggg&#x3D;&#x3D;     --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  The request contains multiple parts and is structured as follows.  The first part is the JSON document that describes the snippet&#39;s properties or meta data. It either has to be the first part, or the request&#39;s &#x60;Content-Type&#x60; header must contain the &#x60;start&#x60; parameter to point to it.  The remaining parts are the files of which there can be zero or more. Each file part should contain the &#x60;Content-ID&#x60; MIME header through which the JSON meta data&#39;s &#x60;files&#x60; element addresses it. The value should be the name of the file.  &#x60;Content-Disposition&#x60; is an optional MIME header. The header&#39;s optional &#x60;filename&#x60; parameter can be used to specify the file name that Bitbucket should use when writing the file to disk. When present, &#x60;filename&#x60; takes precedence over the value of &#x60;Content-ID&#x60;.  When the JSON body omits the &#x60;files&#x60; element, the remaining parts are not ignored. Instead, each file is added to the new snippet as if its name was explicitly linked (the use of the &#x60;files&#x60; elements is mandatory for some operations like deleting or renaming files).   multipart/form-data -------------------  The use of JSON for the snippet&#39;s meta data is optional. Meta data can also be supplied as regular form fields in a more conventional &#x60;multipart/form-data&#x60; request:      $ curl -X POST -u credentials https://api.bitbucket.org/2.0/snippets               -F title&#x3D;\&quot;My snippet\&quot;               -F file&#x3D;@foo.txt -F file&#x3D;@image.png      POST /2.0/snippets HTTP/1.1     Content-Length: 951     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;image.png\&quot;     Content-Type: application/octet-stream      ?PNG      IHDR?1??I.....     ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My snippet     ------------------------------63a4b224c59f--  Here the meta data properties are included as flat, top-level form fields. The file attachments use the &#x60;file&#x60; field name. To attach multiple files, simply repeat the field.  The advantage of &#x60;multipart/form-data&#x60; over &#x60;multipart/related&#x60; is that it can be easier to build clients.  Essentially all properties are optional, &#x60;title&#x60; and &#x60;files&#x60; included.   Sharing and Visibility ----------------------  Snippets can be either public (visible to anyone on Bitbucket, as well as anonymous users), or private (visible only to the owner, creator and members of the team in case the snippet is owned by a team). This is controlled through the snippet&#39;s &#x60;is_private&#x60; element:  * **is_private&#x3D;false** -- everyone, including anonymous users can view   the snippet * **is_private&#x3D;true** -- only the owner and team members (for team   snippets) can view it  To create the snippet under a team account, just append the team name to the URL (see &#x60;/2.0/snippets/{username}&#x60;).

 */
  snippetsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // Snippet | The new snippet object.
    /*let body = new Bitbucket.Snippet();*/ apiInstance.snippetsPost(
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdCommentsPost
  /*


Creates a new comment.  The only required field in the body is &#x60;content.raw&#x60;.  To create a threaded reply to an existing comment, include &#x60;parent.id&#x60;.

 */
  snippetsWorkspaceEncodedIdCommentsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // Snippet | The contents of the new comment.
    /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ /*let body = new Bitbucket.Snippet();*/ apiInstance.snippetsWorkspaceEncodedIdCommentsPost(
      incomingOptions.encodedId,
      incomingOptions.workspace,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspacePost
  /*


Identical to &#x60;/snippets&#x60;, except that the new snippet will be created under the account specified in the path parameter &#x60;{workspace}&#x60;.

 */
  snippetsWorkspacePost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // Snippet | The new snippet object.
    /*let workspace = "workspace_example";*/ /*let body = new Bitbucket.Snippet();*/ apiInstance.snippetsWorkspacePost(
      incomingOptions.workspace,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPost
  /*


Creates a new pull request where the destination repository is this repository and the author is the authenticated user.  The minimum required fields to create a pull request are &#x60;title&#x60; and &#x60;source&#x60;, specified by a branch name.  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/my-username/my-repository/pullrequests \\     -u my-username:my-password \\     --request POST \\     --header &#39;Content-Type: application/json&#39; \\     --data &#39;{         \&quot;title\&quot;: \&quot;My Title\&quot;,         \&quot;source\&quot;: {             \&quot;branch\&quot;: {                 \&quot;name\&quot;: \&quot;staging\&quot;             }         }     }&#39; &#x60;&#x60;&#x60;  If the pull request&#39;s &#x60;destination&#x60; is not specified, it will default to the &#x60;repository.mainbranch&#x60;. To open a pull request to a different branch, say from a feature branch to a staging branch, specify a &#x60;destination&#x60; (same format as the &#x60;source&#x60;):  &#x60;&#x60;&#x60; {     \&quot;title\&quot;: \&quot;My Title\&quot;,     \&quot;source\&quot;: {         \&quot;branch\&quot;: {             \&quot;name\&quot;: \&quot;my-feature-branch\&quot;         }     },     \&quot;destination\&quot;: {         \&quot;branch\&quot;: {             \&quot;name\&quot;: \&quot;staging\&quot;         }     } } &#x60;&#x60;&#x60;  Reviewers can be specified by adding an array of user objects as the &#x60;reviewers&#x60; property.  &#x60;&#x60;&#x60; {     \&quot;title\&quot;: \&quot;My Title\&quot;,     \&quot;source\&quot;: {         \&quot;branch\&quot;: {             \&quot;name\&quot;: \&quot;my-feature-branch\&quot;         }     },     \&quot;reviewers\&quot;: [         {             \&quot;uuid\&quot;: \&quot;{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\&quot;         }     ] } &#x60;&#x60;&#x60;  Other fields:  * &#x60;description&#x60; - a string * &#x60;close_source_branch&#x60; - boolean that specifies if the source branch should be closed upon merging

 */
  repositoriesWorkspaceRepoSlugPullrequestsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Pullrequest() // Pullrequest | The new pull request.  The request URL you POST to becomes the destination repository URL. For this reason, you must specify an explicit source repository in the request object if you want to pull from a different repository (fork).  Since not all elements are required or even mutable, you only need to include the elements you want to initialize, such as the source branch and the title.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost
  /*


Approve the specified pull request as the authenticated user.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprovePost(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost
  /*


Creates a new pull request comment.  Returns the newly created pull request comment.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Number | The id of the pull request // PullrequestComment | The comment object.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullRequestId = 56;*/ /*let body = new Bitbucket.PullrequestComment();*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.pullRequestId,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost
  /*


Declines the pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclinePost(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost
  /*


Merges the pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.PullrequestMergeParameters() // PullrequestMergeParameters |
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergePost(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDownloadsPost
  /*


Upload new download artifacts.  To upload files, perform a &#x60;multipart/form-data&#x60; POST containing one or more &#x60;files&#x60; fields:      $ echo Hello World &gt; hello.txt     $ curl -s -u evzijst -X POST https://api.bitbucket.org/2.0/repositories/evzijst/git-tests/downloads -F files&#x3D;@hello.txt  When a file is uploaded with the same name as an existing artifact, then the existing file will be replaced.

 */
  repositoriesWorkspaceRepoSlugDownloadsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DownloadsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDownloadsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeApprovePost
  /*


Approve the specified commit as the authenticated user.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.

 */
  repositoriesWorkspaceRepoSlugCommitNodeApprovePost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeApprovePost(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeCommentsPost
  /*


Creates new comment on the specified commit.  To post a reply to an existing comment, include the &#x60;parent.id&#x60; field:  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/commit/db9ba1e031d07a02603eae0e559a7adc010257fc/comments/ \\   -X POST -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;One more thing!\&quot;},        \&quot;parent\&quot;: {\&quot;id\&quot;: 5728901}}&#39; &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugCommitNodeCommentsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // CommitComment | The specified comment.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.CommitComment();*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeCommentsPost(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitsPost
  /*


Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**

 */
  repositoriesWorkspaceRepoSlugCommitsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitsRevisionPost
  /*


Identical to &#x60;GET /repositories/{workspace}/{repo_slug}/commits&#x60;, except that POST allows clients to place the include and exclude parameters in the request body to avoid URL length issues.  **Note that this resource does NOT support new commit creation.**

 */
  repositoriesWorkspaceRepoSlugCommitsRevisionPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let revision = "revision_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitsRevisionPost(
      incomingOptions.revision,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for createEnvironment
  /*


Create an environment.

 */
  createEnvironment(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository // DeploymentEnvironment | The environment to create.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.DeploymentEnvironment();*/ apiInstance.createEnvironment(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateEnvironmentForRepository
  /*


Update an environment

 */
  updateEnvironmentForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository // String | The environment UUID.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ apiInstance.updateEnvironmentForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksPost
  /*


Creates a new webhook on the specified repository.  Example:  &#x60;&#x60;&#x60; $ curl -X POST -u credentials -H &#39;Content-Type: application/json&#39;           https://api.bitbucket.org/2.0/repositories/username/slug/hooks           -d &#39;     {       \&quot;description\&quot;: \&quot;Webhook Description\&quot;,       \&quot;url\&quot;: \&quot;https://example.com/\&quot;,       \&quot;active\&quot;: true,       \&quot;events\&quot;: [         \&quot;repo:push\&quot;,         \&quot;issue:created\&quot;,         \&quot;issue:updated\&quot;       ]     }&#39; &#x60;&#x60;&#x60;  Note that this call requires the webhook scope, as well as any scope that applies to the events that the webhook subscribes to. In the example above that means: &#x60;webhook&#x60;, &#x60;repository&#x60; and &#x60;issue&#x60;.  Also note that the &#x60;url&#x60; must properly resolve and cannot be an internal, non-routed address.

 */
  repositoriesWorkspaceRepoSlugHooksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // HookBody |
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.HookBody();*/ apiInstance.repositoriesWorkspaceRepoSlugHooksPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksPost
  /*


Creates a new webhook on the specified team.  Team webhooks are fired for events from all repositories belonging to that team account.  Note that only admins can install webhooks on teams.

 */
  teamsUsernameHooksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.teamsUsernameHooksPost(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksPost
  /*


Creates a new webhook on the specified user account.  Account-level webhooks are fired for events from all repositories belonging to that account.  Note that one can only register webhooks on one&#39;s own account, not that of others.  Also, note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user.
    /*let username = "username_example";*/ apiInstance.usersUsernameHooksPost(
      incomingOptions.username,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameProjectsPost
  /*


Creates a new project.  Note that the avatar has to be embedded as either a data-url or a URL to an external image as shown in the examples below:  &#x60;&#x60;&#x60; $ body&#x3D;$(cat &lt;&lt; EOF {     \&quot;name\&quot;: \&quot;Mars Project\&quot;,     \&quot;key\&quot;: \&quot;MARS\&quot;,     \&quot;description\&quot;: \&quot;Software for colonizing mars.\&quot;,     \&quot;links\&quot;: {         \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/...\&quot;         }     },     \&quot;is_private\&quot;: false } EOF ) $ curl -H \&quot;Content-Type: application/json\&quot; \\        -X POST \\        -d \&quot;$body\&quot; \\        https://api.bitbucket.org/2.0/teams/teams-in-space/projects/ | jq . {   // Serialized project document } &#x60;&#x60;&#x60;  or even:  &#x60;&#x60;&#x60; $ body&#x3D;$(cat &lt;&lt; EOF {     \&quot;name\&quot;: \&quot;Mars Project\&quot;,     \&quot;key\&quot;: \&quot;MARS\&quot;,     \&quot;description\&quot;: \&quot;Software for colonizing mars.\&quot;,     \&quot;links\&quot;: {         \&quot;avatar\&quot;: {             \&quot;href\&quot;: \&quot;http://i.imgur.com/72tRx4w.gif\&quot;         }     },     \&quot;is_private\&quot;: false } EOF ) $ curl -H \&quot;Content-Type: application/json\&quot; \\        -X POST \\        -d \&quot;$body\&quot; \\        https://api.bitbucket.org/2.0/teams/teams-in-space/projects/ | jq . {   // Serialized project document } &#x60;&#x60;&#x60;

 */
  teamsUsernameProjectsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.ProjectsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // Project |
    /*let username = "username_example";*/ /*let body = new Bitbucket.Project();*/ apiInstance.teamsUsernameProjectsPost(
      incomingOptions.username,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameSshKeysPost
  /*


Adds a new SSH public key to the specified user account and returns the resulting key.  Example: &#x60;&#x60;&#x60; $ curl -X POST -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY user@myhost\&quot;}&#39; https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys  {     \&quot;comment\&quot;: \&quot;user@myhost\&quot;,     \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,     \&quot;label\&quot;: \&quot;\&quot;,     \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;         }     },     \&quot;owner\&quot;: {         \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,         \&quot;links\&quot;: {             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;             },             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;             }         },         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;username\&quot;: \&quot;markadams-atl\&quot;,         \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,         \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;     },     \&quot;type\&quot;: \&quot;ssh_key\&quot;,     \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot; } &#x60;&#x60;&#x60;

 */
  usersUsernameSshKeysPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SshApi(); // String | The account's UUID, account_id, or username. Note that username has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
    /*let username = "username_example";*/ let opts = {
      body: new Bitbucket.SshAccountKey() // SshAccountKey | The new SSH key object. Note that the username property has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis).
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.usersUsernameSshKeysPost(
      incomingOptions.username,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsBranchesPost
  /*


Creates a new branch in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/seanfarley/hg/refs/branches \\ -s -u seanfarley -X POST -H \&quot;Content-Type: application/json\&quot; \\ -d &#39;{     \&quot;name\&quot; : \&quot;smf/create-feature\&quot;,     \&quot;target\&quot; : {         \&quot;hash\&quot; : \&quot;default\&quot;,     } }&#39; &#x60;&#x60;&#x60;  This call requires authentication. Private repositories require the caller to authenticate with an account that has appropriate authorization.  For Git, the branch name should not include any prefixes (e.g. refs/heads). This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.  For Mercurial, the authenticated user making this call is the author of the new branch commit and the date is current datetime of the call.

 */
  repositoriesWorkspaceRepoSlugRefsBranchesPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugRefsBranchesPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsTagsPost
  /*


Creates a new tag in the specified repository.  The payload of the POST should consist of a JSON document that contains the name of the tag and the target hash.  &#x60;&#x60;&#x60; curl https://api.bitbucket.org/2.0/repositories/jdoe/myrepo/refs/tags \\ -s -u jdoe -X POST -H \&quot;Content-Type: application/json\&quot; \\ -d &#39;{     \&quot;name\&quot; : \&quot;new-tag-name\&quot;,     \&quot;target\&quot; : {         \&quot;hash\&quot; : \&quot;a1b2c3d4e5f6\&quot;,     } }&#39; &#x60;&#x60;&#x60;  This endpoint does support using short hash prefixes for the commit hash, but it may return a 400 response if the provided prefix is ambiguous. Using a full commit hash is the preferred approach.

 */
  repositoriesWorkspaceRepoSlugRefsTagsPost(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Tag |
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.Tag();*/ apiInstance.repositoriesWorkspaceRepoSlugRefsTagsPost(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  async put(entity, options) {
    switch (entity) {
      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCHING_MODEL_SETTINGS":
        /*



Update the branching model configuration for a repository.  The &#x60;development&#x60; branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a &#x60;development&#x60; property will leave the development branch unchanged.  It is possible for the &#x60;development&#x60; branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the &#x60;is_valid&#x60; field for the branch. It is not possible to update the settings for &#x60;development&#x60; if that would leave the branch in an invalid state. Such a request will be rejected.  The &#x60;production&#x60; branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The &#x60;enabled&#x60; property can be used to enable (&#x60;true&#x60;) or disable (&#x60;false&#x60;) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a &#x60;production&#x60; property will leave the production branch unchanged.  It is possible for the &#x60;production&#x60; branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the &#x60;is_valid&#x60; field for the branch. A request that would leave &#x60;production&#x60; enabled and invalid will be rejected. It is possible to update &#x60;production&#x60; and make it invalid if it would also be left disabled.  The &#x60;branch_types&#x60; property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use &#39;*&#39; inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a &#x60;kind&#x60; property to identify it.  Example Body:  &#x60;&#x60;&#x60;     {       \&quot;development\&quot;: {         \&quot;use_mainbranch\&quot;: true       },       \&quot;production\&quot;: {         \&quot;enabled\&quot;: true,         \&quot;use_mainbranch\&quot;: false,         \&quot;name\&quot;: \&quot;production\&quot;       },       \&quot;branch_types\&quot;: [         {           \&quot;kind\&quot;: \&quot;bugfix\&quot;,           \&quot;enabled\&quot;: true,           \&quot;prefix\&quot;: \&quot;bugfix/\&quot;         },         {           \&quot;kind\&quot;: \&quot;feature\&quot;,           \&quot;enabled\&quot;: true,           \&quot;prefix\&quot;: \&quot;feature/\&quot;         },         {           \&quot;kind\&quot;: \&quot;hotfix\&quot;,           \&quot;prefix\&quot;: \&quot;hotfix/\&quot;         },         {           \&quot;kind\&quot;: \&quot;release\&quot;,           \&quot;enabled\&quot;: false,         }       ]     } &#x60;&#x60;&#x60;


      Function parameters for this API workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USERS_USERNAME_HOOKS_UID":
        /*



Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksUidPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_COMMIT_HOSTED_PROPERTY_VA":
        /*



Update an application property value stored against a commit.


      Function parameters for this API username,repoSlug,commit,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.updateCommitHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_PULL_REQUEST_HOSTED_PROPERTY_VA":
        /*



Update an application property value stored against a pull request.


      Function parameters for this API username,repoSlug,pullrequestId,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.updatePullRequestHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_REPOSITORY_HOSTED_PROPERTY_VA":
        /*



Update an application property value stored against a repository.


      Function parameters for this API username,repoSlug,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_USER_HOSTED_PROPERTY_VA":
        /*



Update an application property value stored against a user.


      Function parameters for this API username,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.updateUserHostedPropertyValue(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES_BUILD_KEY":
        /*



Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * &#x60;state&#x60; * &#x60;name&#x60; * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;refname&#x60;  The &#x60;key&#x60; cannot be changed.


      Function parameters for this API node,key,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEPLOY_KEYS_KEY_ID":
        /*



Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: &#x60;&#x60;&#x60; $ curl -XPUT \\ -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ -H \&quot;Content-type: application/json\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ &#39;{     \&quot;label\&quot;: \&quot;newlabel\&quot;,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\&quot;, }&#39;  Output: {     \&quot;comment\&quot;: \&quot;newcomment\&quot;,     \&quot;last_used\&quot;: null,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234\&quot;         }     },     \&quot;repository\&quot;: {         \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,         \&quot;name\&quot;: \&quot;test\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;label\&quot;: \&quot;newlabel\&quot;,     \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,     \&quot;id\&quot;: 1234,     \&quot;type\&quot;: \&quot;deploy_key\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API keyId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_STATUSES_BUILD_KEY":
        /*



Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * &#x60;state&#x60; * &#x60;name&#x60; * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;refname&#x60;  The &#x60;key&#x60; cannot be changed.


      Function parameters for this API node,key,workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS_UID":
        /*



Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;


      Function parameters for this API workspace,repoSlug,uid
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksUidPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG":
        /*



Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.
      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON_LINKERS_LINKER_KEY_VALUES":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyValuesPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.addonPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_DEPLOYMENT_VARIA":
        /*



Update a deployment environment level variable.


      Function parameters for this API username,repoSlug,environmentUuid,variableUuid,body
        */
        return new Promise((resolve, reject) => {
          this.updateDeploymentVariable(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_PIPELINE_VARIABLE_FOR_T":
        /*



Update a team level variable.


      Function parameters for this API username,variableUuid,body
        */
        return new Promise((resolve, reject) => {
          this.updatePipelineVariableForTeam(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_PIPELINE_VARIABLE_FOR_U":
        /*



Update a user level variable.


      Function parameters for this API username,variableUuid,body
        */
        return new Promise((resolve, reject) => {
          this.updatePipelineVariableForUser(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_REPOSITORY_BUILD_NUM":
        /*



Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryBuildNumber(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "UPDATE_REPOSITORY_PIPELINE_CON":
        /*



Update the pipelines configuration for a repository.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryPipelineConfig(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_REPOSITORY_PIPELINE_KEY_P":
        /*



Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.


      Function parameters for this API username,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryPipelineKeyPair(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_REPOSITORY_PIPELINE_KNOWN_H":
        /*



Update a repository level known host.


      Function parameters for this API username,repoSlug,knownHostUuid,body
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryPipelineKnownHost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_REPOSITORY_PIPELINE_SCHED":
        /*



Update a schedule.


      Function parameters for this API username,repoSlug,scheduleUuid,body
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryPipelineSchedule(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "UPDATE_REPOSITORY_PIPELINE_VARIA":
        /*



Update a repository level variable.


      Function parameters for this API username,repoSlug,variableUuid,body
        */
        return new Promise((resolve, reject) => {
          this.updateRepositoryPipelineVariable(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_COMMENTS_COMMENT_ID":
        /*



Updates the content of the specified issue comment. Note that only the &#x60;content.raw&#x60; field can be modified.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;Lorem ipsum.\&quot;}&#39; &#x60;&#x60;&#x60;


      Function parameters for this API commentId,workspace,username,repoSlug,issueId,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID":
        /*



Modifies the issue.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H &#39;Content-Type: application/json&#39; \\   -d &#39;{   \&quot;title\&quot;: \&quot;Updated title\&quot;,   \&quot;assignee\&quot;: {     \&quot;username\&quot;: \&quot;evzijst\&quot;   },   \&quot;priority\&quot;: \&quot;minor\&quot;,   \&quot;version\&quot;: {     \&quot;name\&quot;: \&quot;1.0\&quot;   },   \&quot;component\&quot;: null }&#39; &#x60;&#x60;&#x60;  This example changes the &#x60;title&#x60;, &#x60;assignee&#x60;, &#x60;priority&#x60; and the &#x60;version&#x60;. It also removes the value of the &#x60;component&#x60; from the issue by setting the field to &#x60;null&#x60;. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the &#x60;/issues/123/changes&#x60; endpoint. It also has a comment associated with the change.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_VOTE":
        /*



Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_WATCH":
        /*



Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCH_RESTRICTIONS_ID":
        /*



Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [&#x60;POST&#x60;](../branch-restrictions#post) for details.


      Function parameters for this API id,workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS_UID":
        /*



Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksUidPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMENTS_COMMENT_ID":
        /*



Updates a comment.  Comments can only be updated by their author.


      Function parameters for this API commentId,encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommentsCommentIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_NODE_ID":
        /*



Identical to &#x60;UPDATE /snippets/encoded_id&#x60;, except that this endpoint takes an explicit commit revision. Only the snippet&#39;s \&quot;HEAD\&quot;/\&quot;tip\&quot; (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted &#x60;/snippets/encoded_id&#x60; could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \&quot;Compare And Swap\&quot;, or CAS operation.  Other than that, the two endpoints are identical in behavior.


      Function parameters for this API workspace,encodedId,nodeId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdNodeIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID":
        /*



Used to update a snippet. Use this to add and delete files and to change a snippet&#39;s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use &#x60;null&#x60;).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * &#x60;application/json&#x60; * &#x60;multipart/related&#x60; * &#x60;multipart/form-data&#x60;  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the &#x60;Content-Type&#x60; and &#x60;Accept&#x60; headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. &#x60;application/json&#x60; does not support file contents and is therefore limited to a snippet&#39;s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: \&quot;Updated title\&quot;}&#39;   To delete the title:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: null}&#39;  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  &#x60;multipart/related&#x60; can be used to manipulate all of a snippet&#39;s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the &#x60;start&#x60; part contains JSON, the mechanism for manipulating the snippet&#39;s meta data is identical to &#x60;application/json&#x60; requests.  To update one of a snippet&#39;s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My updated snippet\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      Updated file contents.      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the &#x60;files&#x60; list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the &#x60;files&#x60; list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;files\&quot;: {         \&quot;image.png\&quot;: {}       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {         \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;bar.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;bar.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;bar.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--   multipart/form-data -----------------  Again, one can also use &#x60;multipart/form-data&#x60; to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title&#x3D;\&quot;My updated snippet\&quot; -F file&#x3D;@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the &#x60;files&#x60; field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files&#x3D;image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary&#x3D;----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name&#x3D;\&quot;files\&quot;      image.png     ------------------------------ef8871065a86--  The explicit use of the &#x60;files&#x60; element in &#x60;multipart/related&#x60; and &#x60;multipart/form-data&#x60; is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in &#x60;files&#x60;, as a convenience to the client.


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_WATCH":
        /*



Used to start watching a specific snippet. Returns 204 (No Content).


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdWatchPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEFAULT_REVIEWERS_TARGET_USERNAME":
        /*



Adds the specified user to the repository&#39;s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.


      Function parameters for this API targetUsername,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_COMMENTS_COMMENT_ID":
        /*



Updates a specific pull request comment.


      Function parameters for this API pullRequestId,commentId,workspace,repoSlug,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID":
        /*



Mutates the specified pull request.  This can be used to change the pull request&#39;s branches or description.  Only open pull requests can be mutated.


      Function parameters for this API workspace,repoSlug,pullRequestId,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS_UID":
        /*



Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;


      Function parameters for this API workspace,repoSlug,uid
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksUidPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS_UID":
        /*



Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksUidPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS_UID":
        /*



Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksUidPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_PROJECTS_PROJECT_KEY":
        /*



Since this endpoint can be used to both update and to create a project, the request body depends on the intent.
      Function parameters for this API username,projectKey,body
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameProjectsProjectKeyPut(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USERS_USERNAME_SSH_KEYS":
        /*



Updates a specific SSH public key on a user&#39;s account  Note: Only the &#39;comment&#39; field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example: &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;label\&quot;: \&quot;Work key\&quot;}&#39; https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a}  {     \&quot;comment\&quot;: \&quot;\&quot;,     \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,     \&quot;label\&quot;: \&quot;Work key\&quot;,     \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;         }     },     \&quot;owner\&quot;: {         \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,         \&quot;links\&quot;: {             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;             },             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;             }         },         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;username\&quot;: \&quot;markadams-atl\&quot;,         \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,         \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;     },     \&quot;type\&quot;: \&quot;ssh_key\&quot;,     \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot; } &#x60;&#x60;&#x60;


      Function parameters for this API username,keyId,opts
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameSshKeysPut(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      default:
        throw ErrorHelper.getError(`Can't get entity`, 404);
    }
  }
  // This is a function for repositoriesWorkspaceRepoSlugBranchingModelSettingsPut
  /*


Update the branching model configuration for a repository.  The &#x60;development&#x60; branch can be configured to a specific branch or to track the main branch. When set to a specific branch it must currently exist. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a &#x60;development&#x60; property will leave the development branch unchanged.  It is possible for the &#x60;development&#x60; branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the &#x60;is_valid&#x60; field for the branch. It is not possible to update the settings for &#x60;development&#x60; if that would leave the branch in an invalid state. Such a request will be rejected.  The &#x60;production&#x60; branch can be a specific branch, the main branch or disabled. When set to a specific branch it must currently exist. The &#x60;enabled&#x60; property can be used to enable (&#x60;true&#x60;) or disable (&#x60;false&#x60;) it. Only the passed properties will be updated. The properties not passed will be left unchanged. A request without a &#x60;production&#x60; property will leave the production branch unchanged.  It is possible for the &#x60;production&#x60; branch to be invalid. This happens when it points at a specific branch that has been deleted. This is indicated in the &#x60;is_valid&#x60; field for the branch. A request that would leave &#x60;production&#x60; enabled and invalid will be rejected. It is possible to update &#x60;production&#x60; and make it invalid if it would also be left disabled.  The &#x60;branch_types&#x60; property contains the branch types to be updated. Only the branch types passed will be updated. All updates will be rejected if it would leave the branching model in an invalid state. For branch types this means that:  1. The prefixes for all enabled branch types are valid. For example,    it is not possible to use &#39;*&#39; inside a Git prefix. 2. A prefix of an enabled branch type must not be a prefix of another    enabled branch type. This is to ensure that a branch can be easily    classified by its prefix unambiguously.  It is possible to store an invalid prefix if that branch type would be left disabled. Only the passed properties will be updated. The properties not passed will be left unchanged. Each branch type must have a &#x60;kind&#x60; property to identify it.  Example Body:  &#x60;&#x60;&#x60;     {       \&quot;development\&quot;: {         \&quot;use_mainbranch\&quot;: true       },       \&quot;production\&quot;: {         \&quot;enabled\&quot;: true,         \&quot;use_mainbranch\&quot;: false,         \&quot;name\&quot;: \&quot;production\&quot;       },       \&quot;branch_types\&quot;: [         {           \&quot;kind\&quot;: \&quot;bugfix\&quot;,           \&quot;enabled\&quot;: true,           \&quot;prefix\&quot;: \&quot;bugfix/\&quot;         },         {           \&quot;kind\&quot;: \&quot;feature\&quot;,           \&quot;enabled\&quot;: true,           \&quot;prefix\&quot;: \&quot;feature/\&quot;         },         {           \&quot;kind\&quot;: \&quot;hotfix\&quot;,           \&quot;prefix\&quot;: \&quot;hotfix/\&quot;         },         {           \&quot;kind\&quot;: \&quot;release\&quot;,           \&quot;enabled\&quot;: false,         }       ]     } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchingModelApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugBranchingModelSettingsPut(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksUidPut
  /*


Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksUidPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.usersUsernameHooksUidPut(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateCommitHostedPropertyValue
  /*


Update an application property value stored against a commit.

 */
  updateCommitHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The commit // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let commit = "commit_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.updateCommitHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.commit,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for updatePullRequestHostedPropertyValue
  /*


Update an application property value stored against a pull request.

 */
  updatePullRequestHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The pull request ID // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullrequestId = "pullrequestId_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.updatePullRequestHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pullrequestId,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for updateRepositoryHostedPropertyValue
  /*


Update an application property value stored against a repository.

 */
  updateRepositoryHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.updateRepositoryHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for updateUserHostedPropertyValue
  /*


Update an application property value stored against a user.

 */
  updateUserHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The user // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.updateUserHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut
  /*


Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * &#x60;state&#x60; * &#x60;name&#x60; * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;refname&#x60;  The &#x60;key&#x60; cannot be changed.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitstatusesApi(); // String | The commit's SHA1 // String | The build status' unique ke // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let key = "key_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Commitstatus() // Commitstatus | The updated build status object
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut(
      incomingOptions.node,
      incomingOptions.key,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut
  /*


Create a new deploy key in a repository.  The same key needs to be passed in but the comment and label can change.  Example: &#x60;&#x60;&#x60; $ curl -XPUT \\ -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ -H \&quot;Content-type: application/json\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 -d \\ &#39;{     \&quot;label\&quot;: \&quot;newlabel\&quot;,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5 newcomment\&quot;, }&#39;  Output: {     \&quot;comment\&quot;: \&quot;newcomment\&quot;,     \&quot;last_used\&quot;: null,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234\&quot;         }     },     \&quot;repository\&quot;: {         \&quot;full_name\&quot;: \&quot;mleu/test\&quot;,         \&quot;name\&quot;: \&quot;test\&quot;,         \&quot;type\&quot;: \&quot;repository\&quot;,         \&quot;uuid\&quot;: \&quot;{85d08b4e-571d-44e9-a507-fa476535aa98}\&quot;     },     \&quot;label\&quot;: \&quot;newlabel\&quot;,     \&quot;created_on\&quot;: \&quot;2018-08-15T23:50:59.993890+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDAK/b1cHHDr/TEV1JGQl+WjCwStKG6Bhrv0rFpEsYlyTBm1fzN0VOJJYn4ZOPCPJwqse6fGbXntEs+BbXiptR+++HycVgl65TMR0b5ul5AgwrVdZdT7qjCOCgaSV74/9xlHDK8oqgGnfA7ZoBBU+qpVyaloSjBdJfLtPY/xqj4yHnXKYzrtn/uFc4Kp9Tb7PUg9Io3qohSTGJGVHnsVblq/rToJG7L5xIo0OxK0SJSQ5vuId93ZuFZrCNMXj8JDHZeSEtjJzpRCBEXHxpOPhAcbm4MzULgkFHhAVgp4JbkrT99/wpvZ7r9AdkTg7HGqL3rlaDrEcWfL7Lu6TnhBdq5\&quot;,     \&quot;id\&quot;: 1234,     \&quot;type\&quot;: \&quot;deploy_key\&quot; } &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DeployApi(); // String | The key ID matching the deploy key // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let keyId = "keyId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDeployKeysKeyIdPut(
      incomingOptions.keyId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut
  /*


Used to update the current status of a build status object on the specific commit.  This operation can also be used to change other properties of the build status:  * &#x60;state&#x60; * &#x60;name&#x60; * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;refname&#x60;  The &#x60;key&#x60; cannot be changed.

 */
  repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | The commit's SHA1 // String | The build status' unique ke // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let key = "key_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Commitstatus() // Commitstatus | The updated build status object
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugCommitNodeStatusesBuildKeyPut(
      incomingOptions.node,
      incomingOptions.key,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksUidPut
  /*


Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;

 */
  repositoriesWorkspaceRepoSlugHooksUidPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The installed webhook's id
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let uid = "uid_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksUidPut(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPut
  /*


Since this endpoint can be used to both update and to create a repository, the request body depends on the intent.   */
  repositoriesWorkspaceRepoSlugPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      body: new Bitbucket.Repository() // Repository | The repository that is to be updated.  Note that the elements \"owner\" and \"full_name\" are ignored since the URL implies them.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugPut(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonLinkersLinkerKeyValuesPut
  /*


 */
  addonLinkersLinkerKeyValuesPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyValuesPut(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonPut
  /*


 */
  addonPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi();
    apiInstance.addonPut((error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for updateDeploymentVariable
  /*


Update a deployment environment level variable.

 */
  updateDeploymentVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The environment // String | The UUID of the variable to update // DeploymentVariable | The updated deployment variable.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ /*let variableUuid = "variableUuid_example";*/ /*let body = new Bitbucket.DeploymentVariable();*/ apiInstance.updateDeploymentVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      incomingOptions.variableUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updatePipelineVariableForTeam
  /*


Update a team level variable.

 */
  updatePipelineVariableForTeam(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The UUID of the variable // PipelineVariable | The updated variable.
    /*let username = "username_example";*/ /*let variableUuid = "variableUuid_example";*/ /*let body = new Bitbucket.PipelineVariable();*/ apiInstance.updatePipelineVariableForTeam(
      incomingOptions.username,
      incomingOptions.variableUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updatePipelineVariableForUser
  /*


Update a user level variable.

 */
  updatePipelineVariableForUser(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The UUID of the variable // PipelineVariable | The updated variable.
    /*let username = "username_example";*/ /*let variableUuid = "variableUuid_example";*/ /*let body = new Bitbucket.PipelineVariable();*/ apiInstance.updatePipelineVariableForUser(
      incomingOptions.username,
      incomingOptions.variableUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateRepositoryBuildNumber
  /*


Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.

 */
  updateRepositoryBuildNumber(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // PipelineBuildNumber | The build number to update.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PipelineBuildNumber();*/ apiInstance.updateRepositoryBuildNumber(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateRepositoryPipelineConfig
  /*


Update the pipelines configuration for a repository.

 */
  updateRepositoryPipelineConfig(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // PipelinesConfig | The updated repository pipelines configuration.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PipelinesConfig();*/ apiInstance.updateRepositoryPipelineConfig(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateRepositoryPipelineKeyPair
  /*


Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.

 */
  updateRepositoryPipelineKeyPair(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // PipelineSshKeyPair | The created or updated SSH key pair.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PipelineSshKeyPair();*/ apiInstance.updateRepositoryPipelineKeyPair(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateRepositoryPipelineKnownHost
  /*


Update a repository level known host.

 */
  updateRepositoryPipelineKnownHost(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the known host to update // PipelineKnownHost | The updated known host.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let knownHostUuid = "knownHostUuid_example";*/ /*let body = new Bitbucket.PipelineKnownHost();*/ apiInstance.updateRepositoryPipelineKnownHost(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.knownHostUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateRepositoryPipelineSchedule
  /*


Update a schedule.

 */
  updateRepositoryPipelineSchedule(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The uuid of the schedule // PipelineSchedule | The schedule to update.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let scheduleUuid = "scheduleUuid_example";*/ /*let body = new Bitbucket.PipelineSchedule();*/ apiInstance.updateRepositoryPipelineSchedule(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.scheduleUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for updateRepositoryPipelineVariable
  /*


Update a repository level variable.

 */
  updateRepositoryPipelineVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the variable to update // PipelineVariable | The updated variable
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let variableUuid = "variableUuid_example";*/ /*let body = new Bitbucket.PipelineVariable();*/ apiInstance.updateRepositoryPipelineVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.variableUuid,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut
  /*


Updates the content of the specified issue comment. Note that only the &#x60;content.raw&#x60; field can be modified.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H &#39;Content-Type: application/json&#39; \\   -d &#39;{\&quot;content\&quot;: {\&quot;raw\&quot;: \&quot;Lorem ipsum.\&quot;}&#39; &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The ID of the issue that is being queried. // IssueComment | The updated comment.
    /*let commentId = "commentId_example";*/ /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let issueId = "issueId_example";*/ /*let body = new Bitbucket.IssueComment();*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdPut(
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.issueId,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdPut
  /*


Modifies the issue.  &#x60;&#x60;&#x60; $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H &#39;Content-Type: application/json&#39; \\   -d &#39;{   \&quot;title\&quot;: \&quot;Updated title\&quot;,   \&quot;assignee\&quot;: {     \&quot;username\&quot;: \&quot;evzijst\&quot;   },   \&quot;priority\&quot;: \&quot;minor\&quot;,   \&quot;version\&quot;: {     \&quot;name\&quot;: \&quot;1.0\&quot;   },   \&quot;component\&quot;: null }&#39; &#x60;&#x60;&#x60;  This example changes the &#x60;title&#x60;, &#x60;assignee&#x60;, &#x60;priority&#x60; and the &#x60;version&#x60;. It also removes the value of the &#x60;component&#x60; from the issue by setting the field to &#x60;null&#x60;. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the &#x60;/issues/123/changes&#x60; endpoint. It also has a comment associated with the change.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdPut(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut
  /*


Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdVotePut(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut
  /*


Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchPut(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut
  /*


Updates an existing branch restriction rule.  Fields not present in the request body are ignored.  See [&#x60;POST&#x60;](../branch-restrictions#post) for details.

 */
  repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchrestrictionsApi(); // String | The restriction rule's i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Branchrestriction | The new version of the existing rule
    /*let id = "id_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.Branchrestriction();*/ apiInstance.repositoriesWorkspaceRepoSlugBranchRestrictionsIdPut(
      incomingOptions.id,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksUidPut
  /*


Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;

 */
  teamsUsernameHooksUidPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.teamsUsernameHooksUidPut(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdCommentsCommentIdPut
  /*


Updates a comment.  Comments can only be updated by their author.

 */
  snippetsWorkspaceEncodedIdCommentsCommentIdPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let commentId = "commentId_example";*/ /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdCommentsCommentIdPut(
      incomingOptions.commentId,
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdNodeIdPut
  /*


Identical to &#x60;UPDATE /snippets/encoded_id&#x60;, except that this endpoint takes an explicit commit revision. Only the snippet&#39;s \&quot;HEAD\&quot;/\&quot;tip\&quot; (most recent) version can be updated and requests on all other, older revisions fail by returning a 405 status.  Usage of this endpoint over the unrestricted &#x60;/snippets/encoded_id&#x60; could be desired if the caller wants to be sure no concurrent modifications have taken place between the moment of the UPDATE request and the original GET.  This can be considered a so-called \&quot;Compare And Swap\&quot;, or CAS operation.  Other than that, the two endpoints are identical in behavior.

 */
  snippetsWorkspaceEncodedIdNodeIdPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet's id // String | A commit revision (SHA1).
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ /*let nodeId = "nodeId_example";*/ apiInstance.snippetsWorkspaceEncodedIdNodeIdPut(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      incomingOptions.nodeId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdPut
  /*


Used to update a snippet. Use this to add and delete files and to change a snippet&#39;s title.  To update a snippet, one can either PUT a full snapshot, or only the parts that need to be changed.  The contract for PUT on this API is that properties missing from the request remain untouched so that snippets can be efficiently manipulated with differential payloads.  To delete a property (e.g. the title, or a file), include its name in the request, but omit its value (use &#x60;null&#x60;).  As in Git, explicit renaming of files is not supported. Instead, to rename a file, delete it and add it again under another name. This can be done atomically in a single request. Rename detection is left to the SCM.  PUT supports three different content types for both request and response bodies:  * &#x60;application/json&#x60; * &#x60;multipart/related&#x60; * &#x60;multipart/form-data&#x60;  The content type used for the request body can be different than that used for the response. Content types are specified using standard HTTP headers.  Use the &#x60;Content-Type&#x60; and &#x60;Accept&#x60; headers to select the desired request and response format.   application/json ----------------  As with creation and retrieval, the content type determines what properties can be manipulated. &#x60;application/json&#x60; does not support file contents and is therefore limited to a snippet&#39;s meta data.  To update the title, without changing any of its files:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: \&quot;Updated title\&quot;}&#39;   To delete the title:      $ curl -X POST -H \&quot;Content-Type: application/json\&quot; https://api.bitbucket.org/2.0/snippets/evzijst/kypj             -d &#39;{\&quot;title\&quot;: null}&#39;  Not all parts of a snippet can be manipulated. The owner and creator for instance are immutable.   multipart/related -----------------  &#x60;multipart/related&#x60; can be used to manipulate all of a snippet&#39;s properties. The body is identical to a POST. properties omitted from the request are left unchanged. Since the &#x60;start&#x60; part contains JSON, the mechanism for manipulating the snippet&#39;s meta data is identical to &#x60;application/json&#x60; requests.  To update one of a snippet&#39;s file contents, while also changing its title:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 288     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;title\&quot;: \&quot;My updated snippet\&quot;,       \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;foo.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;foo.txt\&quot;      Updated file contents.      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  Here only the parts that are changed are included in the body. The other files remain untouched.  Note the use of the &#x60;files&#x60; list in the JSON part. This list contains the files that are being manipulated. This list should have corresponding multiparts in the request that contain the new contents of these files.  If a filename in the &#x60;files&#x60; list does not have a corresponding part, it will be deleted from the snippet, as shown below:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 188     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {       \&quot;files\&quot;: {         \&quot;image.png\&quot;: {}       }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--  To simulate a rename, delete a file and add the same file under another name:      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 212     Content-Type: multipart/related; start&#x3D;\&quot;snippet\&quot;; boundary&#x3D;\&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;\&quot;     MIME-Version: 1.0      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: application/json; charset&#x3D;\&quot;utf-8\&quot;     MIME-Version: 1.0     Content-ID: snippet      {         \&quot;files\&quot;: {           \&quot;foo.txt\&quot;: {},           \&quot;bar.txt\&quot;: {}         }     }      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;     Content-Type: text/plain; charset&#x3D;\&quot;us-ascii\&quot;     MIME-Version: 1.0     Content-Transfer-Encoding: 7bit     Content-ID: \&quot;bar.txt\&quot;     Content-Disposition: attachment; filename&#x3D;\&quot;bar.txt\&quot;      foo      --&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1438169132528273974&#x3D;&#x3D;--   multipart/form-data -----------------  Again, one can also use &#x60;multipart/form-data&#x60; to manipulate file contents and meta data atomically.      $ curl -X PUT http://localhost:12345/2.0/snippets/evzijst/kypj             -F title&#x3D;\&quot;My updated snippet\&quot; -F file&#x3D;@foo.txt      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 351     Content-Type: multipart/form-data; boundary&#x3D;----------------------------63a4b224c59f      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;file\&quot;; filename&#x3D;\&quot;foo.txt\&quot;     Content-Type: text/plain      foo      ------------------------------63a4b224c59f     Content-Disposition: form-data; name&#x3D;\&quot;title\&quot;      My updated snippet     ------------------------------63a4b224c59f  To delete a file, omit its contents while including its name in the &#x60;files&#x60; field:      $ curl -X PUT https://api.bitbucket.org/2.0/snippets/evzijst/kypj -F files&#x3D;image.png      PUT /2.0/snippets/evzijst/kypj HTTP/1.1     Content-Length: 149     Content-Type: multipart/form-data; boundary&#x3D;----------------------------ef8871065a86      ------------------------------ef8871065a86     Content-Disposition: form-data; name&#x3D;\&quot;files\&quot;      image.png     ------------------------------ef8871065a86--  The explicit use of the &#x60;files&#x60; element in &#x60;multipart/related&#x60; and &#x60;multipart/form-data&#x60; is only required when deleting files. The default mode of operation is for file parts to be processed, regardless of whether or not they are listed in &#x60;files&#x60;, as a convenience to the client.

 */
  snippetsWorkspaceEncodedIdPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet's id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdPut(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdWatchPut
  /*


Used to start watching a specific snippet. Returns 204 (No Content).

 */
  snippetsWorkspaceEncodedIdWatchPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdWatchPut(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut
  /*


Adds the specified user to the repository&#39;s list of default reviewers.  This method is idempotent. Adding a user a second time has no effect.

 */
  repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let targetUsername = "targetUsername_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernamePut(
      incomingOptions.targetUsername,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut
  /*


Updates a specific pull request comment.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // PullrequestComment | The contents of the updated comment.
    /*let pullRequestId = "pullRequestId_example";*/ /*let commentId = "commentId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let body = new Bitbucket.PullrequestComment();*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdPut(
      incomingOptions.pullRequestId,
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut
  /*


Mutates the specified pull request.  This can be used to change the pull request&#39;s branches or description.  Only open pull requests can be mutated.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // Number | The id of the pull request.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullRequestId = 56;*/ let opts = {
      body: new Bitbucket.Pullrequest() // Pullrequest | The pull request that is to be updated.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPut(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.pullRequestId,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksUidPut
  /*


Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;

 */
  repositoriesWorkspaceRepoSlugHooksUidPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The installed webhook's id
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let uid = "uid_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksUidPut(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksUidPut
  /*


Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;

 */
  teamsUsernameHooksUidPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.teamsUsernameHooksUidPut(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksUidPut
  /*


Updates the specified webhook subscription.  The following properties can be mutated:  * &#x60;description&#x60; * &#x60;url&#x60; * &#x60;active&#x60; * &#x60;events&#x60;  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksUidPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.usersUsernameHooksUidPut(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for teamsUsernameProjectsProjectKeyPut
  /*


Since this endpoint can be used to both update and to create a project, the request body depends on the intent.   */
  teamsUsernameProjectsProjectKeyPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.ProjectsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The project in question. This can either be the actual `key` assigned to the project or the `UUID` (surrounded by curly-braces (`{}`)). // Project |
    /*let username = "username_example";*/ /*let projectKey = "projectKey_example";*/ /*let body = new Bitbucket.Project();*/ apiInstance.teamsUsernameProjectsProjectKeyPut(
      incomingOptions.username,
      incomingOptions.projectKey,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for usersUsernameSshKeysPut
  /*


Updates a specific SSH public key on a user&#39;s account  Note: Only the &#39;comment&#39; field can be updated using this API. To modify the key or comment values, you must delete and add the key again.  Example: &#x60;&#x60;&#x60; $ curl -X PUT -H \&quot;Content-Type: application/json\&quot; -d &#39;{\&quot;label\&quot;: \&quot;Work key\&quot;}&#39; https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a}  {     \&quot;comment\&quot;: \&quot;\&quot;,     \&quot;created_on\&quot;: \&quot;2018-03-14T13:17:05.196003+00:00\&quot;,     \&quot;key\&quot;: \&quot;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKqP3Cr632C2dNhhgKVcon4ldUSAeKiku2yP9O9/bDtY\&quot;,     \&quot;label\&quot;: \&quot;Work key\&quot;,     \&quot;last_used\&quot;: \&quot;2018-03-20T13:18:05.196003+00:00\&quot;,     \&quot;links\&quot;: {         \&quot;self\&quot;: {             \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/b15b6026-9c02-4626-b4ad-b905f99f763a\&quot;         }     },     \&quot;owner\&quot;: {         \&quot;display_name\&quot;: \&quot;Mark Adams\&quot;,         \&quot;links\&quot;: {             \&quot;avatar\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/account/markadams-atl/avatar/32/\&quot;             },             \&quot;html\&quot;: {                 \&quot;href\&quot;: \&quot;https://bitbucket.org/markadams-atl/\&quot;             },             \&quot;self\&quot;: {                 \&quot;href\&quot;: \&quot;https://api.bitbucket.org/2.0/users/markadams-atl\&quot;             }         },         \&quot;type\&quot;: \&quot;user\&quot;,         \&quot;username\&quot;: \&quot;markadams-atl\&quot;,         \&quot;nickname\&quot;: \&quot;markadams-atl\&quot;,         \&quot;uuid\&quot;: \&quot;{d7dd0e2d-3994-4a50-a9ee-d260b6cefdab}\&quot;     },     \&quot;type\&quot;: \&quot;ssh_key\&quot;,     \&quot;uuid\&quot;: \&quot;{b15b6026-9c02-4626-b4ad-b905f99f763a}\&quot; } &#x60;&#x60;&#x60;

 */
  usersUsernameSshKeysPut(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SshApi(); // String | The account's username or UUID // String | The SSH key's UUID value.
    /*let username = "username_example";*/ /*let keyId = "keyId_example";*/ let opts = {
      body: new Bitbucket.SshAccountKey() // SshAccountKey | The updated SSH key object
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.usersUsernameSshKeysPut(
      incomingOptions.username,
      incomingOptions.keyId,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  async delete(entity, options) {
    switch (entity) {
      case "USERS_USERNAME_HOOKS_UID":
        /*



Deletes the specified webhook subscription from the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksUidDelete(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "DELETE_COMMIT_HOSTED_PROPERT":
        /*



Delete an application property value stored against a commit.


      Function parameters for this API username,repoSlug,commit,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.deleteCommitHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_PULL_REQUEST_HOSTED_PROPERT":
        /*



Delete an application property value stored against a pull request.


      Function parameters for this API username,repoSlug,pullrequestId,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.deletePullRequestHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_REPOSITORY_HOSTED_PROPERT":
        /*



Delete an application property value stored against a repository.


      Function parameters for this API username,repoSlug,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.deleteRepositoryHostedPropertyValue(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_USER_HOSTED_PROPERT":
        /*



Delete an application property value stored against a user.


      Function parameters for this API username,appKey,propertyName
        */
        return new Promise((resolve, reject) => {
          this.deleteUserHostedPropertyValue(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEPLOY_KEYS_KEY_ID":
        /*



This deletes a deploy key from a repository.  Example: &#x60;&#x60;&#x60; $ curl -XDELETE \\ -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 &#x60;&#x60;&#x60;


      Function parameters for this API keyId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG":
        /*



Deletes the repository. This is an irreversible operation.  This does not affect its forks.


      Function parameters for this API workspace,repoSlug,opts
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS_UID":
        /*



Deletes the specified webhook subscription from the given repository.


      Function parameters for this API workspace,repoSlug,uid
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksUidDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON":
        /*




      Function parameters for this API
        */
        return new Promise((resolve, reject) => {
          this.addonDelete(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "ADDON_LINKERS_LINKER_KEY_VALUES":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyValuesDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "ADDON_LINKERS_LINKER_KEY_VALUES_DE":
        /*




      Function parameters for this API linkerKey
        */
        return new Promise((resolve, reject) => {
          this.addonLinkersLinkerKeyValuesDelete_0(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_DEPLOYMENT_VA":
        /*



Delete a deployment environment level variable.


      Function parameters for this API username,repoSlug,environmentUuid,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.deleteDeploymentVariable(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "DELETE_PIPELINE_VARIABLE_F":
        /*



Delete a team level variable.


      Function parameters for this API username,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.deletePipelineVariableForTeam(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "DELETE_PIPELINE_VARIABLE_F":
        /*



Delete an account level variable.


      Function parameters for this API username,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.deletePipelineVariableForUser(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "DELETE_REPOSITORY_PIPELINE_K":
        /*



Delete the repository SSH key pair.


      Function parameters for this API username,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.deleteRepositoryPipelineKeyPair(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_REPOSITORY_PIPELINE_KNO":
        /*



Delete a repository level known host.


      Function parameters for this API username,repoSlug,knownHostUuid
        */
        return new Promise((resolve, reject) => {
          this.deleteRepositoryPipelineKnownHost(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_REPOSITORY_PIPELINE_SC":
        /*



Delete a schedule.


      Function parameters for this API username,repoSlug,scheduleUuid
        */
        return new Promise((resolve, reject) => {
          this.deleteRepositoryPipelineSchedule(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_REPOSITORY_PIPELINE_VA":
        /*



Delete a repository level variable.


      Function parameters for this API username,repoSlug,variableUuid
        */
        return new Promise((resolve, reject) => {
          this.deleteRepositoryPipelineVariable(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_ATTACHMENTS_PATH":
        /*



Deletes an attachment.


      Function parameters for this API path,issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_COMMENTS_COMMENT_ID":
        /*



Deletes the specified comment.


      Function parameters for this API commentId,workspace,username,repoSlug,issueId,body
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID":
        /*



Deletes the specified issue. This requires write access to the repository.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_VOTE":
        /*



Retract your vote.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_ISSUES_ISSUE_ID_WATCH":
        /*



Stop watching this issue.


      Function parameters for this API issueId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_BRANCH_RESTRICTIONS_ID":
        /*



Deletes an existing branch restriction rule.


      Function parameters for this API id,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS_UID":
        /*



Deletes the specified webhook subscription from the given team account.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksUidDelete(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_COMMENTS_COMMENT_ID":
        /*



Deletes a snippet comment.  Comments can only be removed by their author.


      Function parameters for this API commentId,encodedId,workspace
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdCommentsCommentIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID":
        /*



Deletes a snippet and returns an empty response.


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_NODE_ID":
        /*



Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use &#x60;DELETE /snippets/{encoded_id}&#x60; instead.


      Function parameters for this API nodeId,workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdNodeIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "SNIPPETS_WORKSPACE_ENCODED_ID_WATCH":
        /*



Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.


      Function parameters for this API workspace,encodedId
        */
        return new Promise((resolve, reject) => {
          this.snippetsWorkspaceEncodedIdWatchDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DEFAULT_REVIEWERS_TARGET_USERNAME":
        /*



Removes a default reviewer from the repository.


      Function parameters for this API targetUsername,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_APPROVE":
        /*



Redact the authenticated user&#39;s approval of the specified pull request.


      Function parameters for this API pullRequestId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_PULLREQUESTS_PULL_REQUEST_ID_COMMENTS_COMMENT_ID":
        /*



Deletes a specific pull request comment.


      Function parameters for this API pullRequestId,commentId,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_DOWNLOADS_FILENAME":
        /*



Deletes the specified download artifact from the repository.


      Function parameters for this API filename,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_COMMIT_NODE_APPROVE":
        /*



Redact the authenticated user&#39;s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.


      Function parameters for this API node,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugCommitNodeApproveDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "DELETE_ENVIRONMENT_FOR_REPO":
        /*



Delete an environment


      Function parameters for this API username,repoSlug,environmentUuid
        */
        return new Promise((resolve, reject) => {
          this.deleteEnvironmentForRepository(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_HOOKS_UID":
        /*



Deletes the specified webhook subscription from the given repository.


      Function parameters for this API workspace,repoSlug,uid
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugHooksUidDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "TEAMS_USERNAME_HOOKS_UID":
        /*



Deletes the specified webhook subscription from the given team account.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameHooksUidDelete(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "USERS_USERNAME_HOOKS_UID":
        /*



Deletes the specified webhook subscription from the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.


      Function parameters for this API username,uid
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameHooksUidDelete(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "TEAMS_USERNAME_PROJECTS_PROJECT_KEY":
        /*




      Function parameters for this API username,projectKey
        */
        return new Promise((resolve, reject) => {
          this.teamsUsernameProjectsProjectKeyDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "USERS_USERNAME_SSH_KEYS":
        /*



Deletes a specific SSH public key from a user&#39;s account  Example: &#x60;&#x60;&#x60; $ curl -X DELETE https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} &#x60;&#x60;&#x60;


      Function parameters for this API username,keyId
        */
        return new Promise((resolve, reject) => {
          this.usersUsernameSshKeysDelete(options, (err, data, response) => {
            if (err) {
              reject({ error: err, response: response });
            }
            resolve({ data: data, response: response });
          });
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_BRANCHES_NAME":
        /*



Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  For Git, the branch name should not include any prefixes (e.g. refs/heads). For Mercurial, this closes all open heads on the branch, sets the author of the commit to the authenticated caller, and changes the date to the datetime of the call.


      Function parameters for this API name,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      case "REPOSITORIES_WORKSPACE_REPO_SLUG_REFS_TAGS_NAME":
        /*



Delete a tag in the specified repository.  For Git, the tag name should not include any prefixes (e.g. refs/tags). For Mercurial, this adds a commit to the main branch that removes the specified tag.


      Function parameters for this API name,workspace,repoSlug
        */
        return new Promise((resolve, reject) => {
          this.repositoriesWorkspaceRepoSlugRefsTagsNameDelete(
            options,
            (err, data, response) => {
              if (err) {
                reject({ error: err, response: response });
              }
              resolve({ data: data, response: response });
            }
          );
        });

      default:
        throw ErrorHelper.getError(`Can't get entity`, 404);
    }
  }
  // This is a function for usersUsernameHooksUidDelete
  /*


Deletes the specified webhook subscription from the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksUidDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.UsersApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.usersUsernameHooksUidDelete(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteCommitHostedPropertyValue
  /*


Delete an application property value stored against a commit.

 */
  deleteCommitHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The commit // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let commit = "commit_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.deleteCommitHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.commit,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deletePullRequestHostedPropertyValue
  /*


Delete an application property value stored against a pull request.

 */
  deletePullRequestHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The pull request ID // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let pullrequestId = "pullrequestId_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.deletePullRequestHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.pullrequestId,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteRepositoryHostedPropertyValue
  /*


Delete an application property value stored against a repository.

 */
  deleteRepositoryHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The account // String | The repository // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.deleteRepositoryHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteUserHostedPropertyValue
  /*


Delete an application property value stored against a user.

 */
  deleteUserHostedPropertyValue(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PropertiesApi(); // String | The user // String | The key of the Connect app // String | The name of the property.
    /*let username = "username_example";*/ /*let appKey = "appKey_example";*/ /*let propertyName = "propertyName_example";*/ apiInstance.deleteUserHostedPropertyValue(
      incomingOptions.username,
      incomingOptions.appKey,
      incomingOptions.propertyName,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete
  /*


This deletes a deploy key from a repository.  Example: &#x60;&#x60;&#x60; $ curl -XDELETE \\ -H \&quot;Authorization &lt;auth header&gt;\&quot; \\ https://api.bitbucket.org/2.0/repositories/mleu/test/deploy-keys/1234 &#x60;&#x60;&#x60;

 */
  repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DeployApi(); // String | The key ID matching the deploy key // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let keyId = "keyId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDeployKeysKeyIdDelete(
      incomingOptions.keyId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDelete
  /*


Deletes the repository. This is an irreversible operation.  This does not affect its forks.

 */
  repositoriesWorkspaceRepoSlugDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ let opts = {
      //  'redirectTo': "redirectTo_example" // String | If a repository has been moved to a new location, use this parameter to show users a friendly message in the Bitbucket UI that the repository has moved to a new location. However, a GET to this endpoint will still return a 404.
    };

    Object.keys(incomingOptions.opts).forEach(
      key =>
        incomingOptions.opts[key] === undefined &&
        delete incomingOptions.opts[key]
    );
    incomingOptions.opts = Object.assign(opts, incomingOptions.opts);

    apiInstance.repositoriesWorkspaceRepoSlugDelete(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.opts,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksUidDelete
  /*


Deletes the specified webhook subscription from the given repository.

 */
  repositoriesWorkspaceRepoSlugHooksUidDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RepositoriesApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The installed webhook's id
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let uid = "uid_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksUidDelete(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for addonDelete
  /*


 */
  addonDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi();
    apiInstance.addonDelete((error, data, response) => {
      if (error) {
        cb(error, null, response);
      } else {
        cb(null, data, response);
      }
    });
  }

  // This is a function for addonLinkersLinkerKeyValuesDelete
  /*


 */
  addonLinkersLinkerKeyValuesDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyValuesDelete(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for addonLinkersLinkerKeyValuesDelete_0
  /*


 */
  addonLinkersLinkerKeyValuesDelete_0(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.AddonApi(); // String |
    /*let linkerKey = "linkerKey_example";*/ apiInstance.addonLinkersLinkerKeyValuesDelete_0(
      incomingOptions.linkerKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for deleteDeploymentVariable
  /*


Delete a deployment environment level variable.

 */
  deleteDeploymentVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The environment // String | The UUID of the variable to delete.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.deleteDeploymentVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deletePipelineVariableForTeam
  /*


Delete a team level variable.

 */
  deletePipelineVariableForTeam(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The UUID of the variable to delete.
    /*let username = "username_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.deletePipelineVariableForTeam(
      incomingOptions.username,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deletePipelineVariableForUser
  /*


Delete an account level variable.

 */
  deletePipelineVariableForUser(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The UUID of the variable to delete.
    /*let username = "username_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.deletePipelineVariableForUser(
      incomingOptions.username,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteRepositoryPipelineKeyPair
  /*


Delete the repository SSH key pair.

 */
  deleteRepositoryPipelineKeyPair(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.deleteRepositoryPipelineKeyPair(
      incomingOptions.username,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteRepositoryPipelineKnownHost
  /*


Delete a repository level known host.

 */
  deleteRepositoryPipelineKnownHost(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the known host to delete.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let knownHostUuid = "knownHostUuid_example";*/ apiInstance.deleteRepositoryPipelineKnownHost(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.knownHostUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteRepositoryPipelineSchedule
  /*


Delete a schedule.

 */
  deleteRepositoryPipelineSchedule(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The uuid of the schedule.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let scheduleUuid = "scheduleUuid_example";*/ apiInstance.deleteRepositoryPipelineSchedule(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.scheduleUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteRepositoryPipelineVariable
  /*


Delete a repository level variable.

 */
  deleteRepositoryPipelineVariable(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.PipelinesApi(); // String | The account // String | The repository // String | The UUID of the variable to delete.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let variableUuid = "variableUuid_example";*/ apiInstance.deleteRepositoryPipelineVariable(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.variableUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete
  /*


Deletes an attachment.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let path = "path_example";*/ /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathDelete(
      incomingOptions.path,
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete
  /*


Deletes the specified comment.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the username or the UUID of the user, surrounded by curly-braces, for example: `{user UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The ID of the issue that is being queried. // IssueComment | The updated comment.
    /*let commentId = "commentId_example";*/ /*let workspace = "workspace_example";*/ /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let issueId = "issueId_example";*/ /*let body = new Bitbucket.IssueComment();*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdDelete(
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.issueId,
      incomingOptions.body,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdDelete
  /*


Deletes the specified issue. This requires write access to the repository.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdDelete(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete
  /*


Retract your vote.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdVoteDelete(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete
  /*


Stop watching this issue.

 */
  repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.IssueTrackerApi(); // String | The issue i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let issueId = "issueId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugIssuesIssueIdWatchDelete(
      incomingOptions.issueId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete
  /*


Deletes an existing branch restriction rule.

 */
  repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.BranchrestrictionsApi(); // String | The restriction rule's i // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let id = "id_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugBranchRestrictionsIdDelete(
      incomingOptions.id,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksUidDelete
  /*


Deletes the specified webhook subscription from the given team account.

 */
  teamsUsernameHooksUidDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.TeamsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.teamsUsernameHooksUidDelete(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdCommentsCommentIdDelete
  /*


Deletes a snippet comment.  Comments can only be removed by their author.

 */
  snippetsWorkspaceEncodedIdCommentsCommentIdDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`.
    /*let commentId = "commentId_example";*/ /*let encodedId = "encodedId_example";*/ /*let workspace = "workspace_example";*/ apiInstance.snippetsWorkspaceEncodedIdCommentsCommentIdDelete(
      incomingOptions.commentId,
      incomingOptions.encodedId,
      incomingOptions.workspace,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdDelete
  /*


Deletes a snippet and returns an empty response.

 */
  snippetsWorkspaceEncodedIdDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet's id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdDelete(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdNodeIdDelete
  /*


Deletes the snippet.  Note that this only works for versioned URLs that point to the latest commit of the snippet. Pointing to an older commit results in a 405 status code.  To delete a snippet, regardless of whether or not concurrent changes are being made to it, use &#x60;DELETE /snippets/{encoded_id}&#x60; instead.

 */
  snippetsWorkspaceEncodedIdNodeIdDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet's id.
    /*let nodeId = "nodeId_example";*/ /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdNodeIdDelete(
      incomingOptions.nodeId,
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for snippetsWorkspaceEncodedIdWatchDelete
  /*


Used to stop watching a specific snippet. Returns 204 (No Content) to indicate success.

 */
  snippetsWorkspaceEncodedIdWatchDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SnippetsApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | The snippet id.
    /*let workspace = "workspace_example";*/ /*let encodedId = "encodedId_example";*/ apiInstance.snippetsWorkspaceEncodedIdWatchDelete(
      incomingOptions.workspace,
      incomingOptions.encodedId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete
  /*


Removes a default reviewer from the repository.

 */
  repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | This can either be the username or the UUID of the default reviewer, surrounded by curly-braces, for example: `{account UUID}`. // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let targetUsername = "targetUsername_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameDelete(
      incomingOptions.targetUsername,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete
  /*


Redact the authenticated user&#39;s approval of the specified pull request.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveDelete(
      incomingOptions.pullRequestId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete
  /*


Deletes a specific pull request comment.

 */
  repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(
    incomingOptions,
    cb
  ) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.PullrequestsApi(); // String | // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let pullRequestId = "pullRequestId_example";*/ /*let commentId = "commentId_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdDelete(
      incomingOptions.pullRequestId,
      incomingOptions.commentId,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugDownloadsFilenameDelete
  /*


Deletes the specified download artifact from the repository.

 */
  repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.DownloadsApi(); // String | // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let filename = "filename_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugDownloadsFilenameDelete(
      incomingOptions.filename,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, data, response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugCommitNodeApproveDelete
  /*


Redact the authenticated user&#39;s approval of the specified commit.  This operation is only available to users that have explicit access to the repository. In contrast, just the fact that a repository is publicly accessible to users does not give them the ability to approve commits.

 */
  repositoriesWorkspaceRepoSlugCommitNodeApproveDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.CommitsApi(); // String | The commit's SHA1 // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let node = "node_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugCommitNodeApproveDelete(
      incomingOptions.node,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for deleteEnvironmentForRepository
  /*


Delete an environment

 */
  deleteEnvironmentForRepository(incomingOptions, cb) {
    const Bitbucket = require("./dist");

    let apiInstance = new Bitbucket.DeploymentsApi(); // String | The account // String | The repository // String | The environment UUID.
    /*let username = "username_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let environmentUuid = "environmentUuid_example";*/ apiInstance.deleteEnvironmentForRepository(
      incomingOptions.username,
      incomingOptions.repoSlug,
      incomingOptions.environmentUuid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugHooksUidDelete
  /*


Deletes the specified webhook subscription from the given repository.

 */
  repositoriesWorkspaceRepoSlugHooksUidDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`. // String | The installed webhook's id
    /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ /*let uid = "uid_example";*/ apiInstance.repositoriesWorkspaceRepoSlugHooksUidDelete(
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for teamsUsernameHooksUidDelete
  /*


Deletes the specified webhook subscription from the given team account.

 */
  teamsUsernameHooksUidDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.teamsUsernameHooksUidDelete(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for usersUsernameHooksUidDelete
  /*


Deletes the specified webhook subscription from the given user account.  Note that the username path parameter has been deprecated due to [privacy changes](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#removal-of-usernames-from-user-referencing-apis). Use the account&#39;s UUID or account_id instead.

 */
  usersUsernameHooksUidDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.WebhooksApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The installed webhook's id
    /*let username = "username_example";*/ /*let uid = "uid_example";*/ apiInstance.usersUsernameHooksUidDelete(
      incomingOptions.username,
      incomingOptions.uid,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for teamsUsernameProjectsProjectKeyDelete
  /*


 */
  teamsUsernameProjectsProjectKeyDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.ProjectsApi(); // String | This can either be the username or the UUID of the account, surrounded by curly-braces, for example: `{account UUID}`. An account is either a team or user. // String | The project in question. This can either be the actual `key` assigned to the project or the `UUID` (surrounded by curly-braces (`{}`)).
    /*let username = "username_example";*/ /*let projectKey = "projectKey_example";*/ apiInstance.teamsUsernameProjectsProjectKeyDelete(
      incomingOptions.username,
      incomingOptions.projectKey,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for usersUsernameSshKeysDelete
  /*


Deletes a specific SSH public key from a user&#39;s account  Example: &#x60;&#x60;&#x60; $ curl -X DELETE https://api.bitbucket.org/2.0/users/markadams-atl/ssh-keys/{b15b6026-9c02-4626-b4ad-b905f99f763a} &#x60;&#x60;&#x60;

 */
  usersUsernameSshKeysDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.SshApi(); // String | The account's username or UUID // String | The SSH key's UUID value.
    /*let username = "username_example";*/ /*let keyId = "keyId_example";*/ apiInstance.usersUsernameSshKeysDelete(
      incomingOptions.username,
      incomingOptions.keyId,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsBranchesNameDelete
  /*


Delete a branch in the specified repository.  The main branch is not allowed to be deleted and will return a 400 response.  For Git, the branch name should not include any prefixes (e.g. refs/heads). For Mercurial, this closes all open heads on the branch, sets the author of the commit to the authenticated caller, and changes the date to the datetime of the call.

 */
  repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | The name of the branch // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let name = "name_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugRefsBranchesNameDelete(
      incomingOptions.name,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  // This is a function for repositoriesWorkspaceRepoSlugRefsTagsNameDelete
  /*


Delete a tag in the specified repository.  For Git, the tag name should not include any prefixes (e.g. refs/tags). For Mercurial, this adds a commit to the main branch that removes the specified tag.

 */
  repositoriesWorkspaceRepoSlugRefsTagsNameDelete(incomingOptions, cb) {
    const Bitbucket = require("./dist");
    let defaultClient = Bitbucket.ApiClient.instance;
    // Configure API key authorization: api_key
    let api_key = defaultClient.authentications["api_key"];
    api_key.apiKey = incomingOptions.apiKey;
    // Uncomment the following line to set a prefix for the API key, e.g. "Token" (defaults to null)
    api_key.apiKeyPrefix = incomingOptions.apiKeyPrefix || "Token";
    // Configure HTTP basic authorization: basic
    let basic = defaultClient.authentications["basic"];
    basic.username = "YOUR USERNAME";
    basic.password = "YOUR PASSWORD";
    // Configure OAuth2 access token for authorization: oauth2
    let oauth2 = defaultClient.authentications["oauth2"];
    oauth2.accessToken = incomingOptions.accessToken;

    let apiInstance = new Bitbucket.RefsApi(); // String | The name of the tag // String | This can either be the workspace ID (slug) or the workspace UUID surrounded by curly-braces, for example: `{workspace UUID}`. // String | This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: `{repository UUID}`.
    /*let name = "name_example";*/ /*let workspace = "workspace_example";*/ /*let repoSlug = "repoSlug_example";*/ apiInstance.repositoriesWorkspaceRepoSlugRefsTagsNameDelete(
      incomingOptions.name,
      incomingOptions.workspace,
      incomingOptions.repoSlug,
      (error, data, response) => {
        if (error) {
          cb(error, null, response);
        } else {
          cb(null, "", response);
        }
      }
    );
  }

  async patch(entity, options) {
    switch (entity) {
      default:
        throw ErrorHelper.getError(`Can't get entity`, 404);
    }
  }
}
module.exports = new BitbucketService();
